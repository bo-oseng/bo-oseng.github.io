<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-06-11T18:03:48+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">BO___OSENG</title><subtitle>개발학습 블로그 입니다.</subtitle><author><name>Kim Boseong</name></author><entry><title type="html"></title><link href="http://localhost:4000/2022-02-23-boj-3085/" rel="alternate" type="text/html" title="" /><published>2022-06-11T18:03:48+09:00</published><updated>2022-06-11T18:03:48+09:00</updated><id>http://localhost:4000/2022-02-23-boj-3085</id><content type="html" xml:base="http://localhost:4000/2022-02-23-boj-3085/"><![CDATA[<h2 id="풀이">풀이</h2>

<p>입력이 3&lt;=n&lt;=50으로 제한되어 있고, 비교적 작을 수 이므로 단순하게 하나씩 비교해 나가면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

 <span class="c1"># 사탕의 상태를 입력 받을 배열 선언
</span><span class="n">candy</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>

     <span class="c1"># 각 사탕의 색을 하나씩 쪼개서 List[str]형태로 저장
</span>    <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

 <span class="c1"># 사탕을 먹을 수 있을때 최댓값을 세는 함수 선언
</span><span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="n">candy</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">cnt</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">int</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>

        <span class="n">tmp1</span><span class="p">,</span><span class="n">tmp2</span> <span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    
             <span class="c1"># 좌우로 인접한 사탕의 종류가 같다면 먹을 수 있고 
</span>             <span class="c1"># 카운트를 위해 같다면 1을 계속 더해줌
</span>            <span class="k">if</span> <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>

                <span class="n">tmp1</span><span class="o">+=</span><span class="mi">1</span>

             <span class="c1"># 만약 다른 종류가 나온다면 1로 초기화
</span>            <span class="k">else</span><span class="p">:</span>

                <span class="n">tmp1</span><span class="o">=</span><span class="mi">1</span>

             <span class="c1"># 상하로 인접한 사탕의 종류가 같다면 먹을 수 있고
</span>             <span class="c1"># 카운트를 위해 같다면 1을 계속 더해줌
</span>            <span class="k">if</span> <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>

                <span class="n">tmp2</span><span class="o">+=</span><span class="mi">1</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">tmp2</span><span class="o">=</span><span class="mi">1</span>

             <span class="c1"># 입력받은 cnt와 tmp1,tmp2중 최대를 cnt에 저장
</span>            <span class="n">cnt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span><span class="n">tmp1</span><span class="p">,</span><span class="n">tmp2</span><span class="p">)</span>
 
    <span class="k">return</span> <span class="n">cnt</span>



<span class="n">cnt</span><span class="p">,</span><span class="n">cnt1</span><span class="p">,</span><span class="n">cnt2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

         <span class="c1"># 좌우 종류가 다른경우 서로 바꾸고 eat함수를 호출,
</span>         <span class="c1"># eat 함수로 cnt1를 계산한뒤 다시 원래 상태로 되돌림
</span>        <span class="k">if</span> <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>

            <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

            <span class="n">cnt1</span> <span class="o">=</span> <span class="n">eat</span><span class="p">(</span><span class="n">candy</span><span class="p">,</span><span class="n">cnt</span><span class="p">)</span>

            <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">candy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

         <span class="c1"># 상하 종류가 다른경우 서로 바꾸고 eat함수를 호출,
</span>         <span class="c1"># eat 함수로 cnt2를 계산한뒤 다시 원래 상태도 되돌림
</span>        <span class="k">if</span> <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>

            <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

            <span class="n">cnt2</span> <span class="o">=</span> <span class="n">eat</span><span class="p">(</span><span class="n">candy</span><span class="p">,</span><span class="n">cnt</span><span class="p">)</span>

            <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">candy</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="n">cnt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cnt1</span><span class="p">,</span><span class="n">cnt2</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3
ZCY
ZCP
PYZ
[['C', 'Z', 'Y'], ['Z', 'C', 'P'], ['P', 'Y', 'Z']]
[['Z', 'Y', 'C'], ['Z', 'C', 'P'], ['P', 'Y', 'Z']]
[['Z', 'C', 'Y'], ['P', 'C', 'P'], ['Z', 'Y', 'Z']]
[['Z', 'C', 'Y'], ['C', 'Z', 'P'], ['P', 'Y', 'Z']]
[['Z', 'C', 'Y'], ['Z', 'P', 'C'], ['P', 'Y', 'Z']]
[['Z', 'C', 'Y'], ['Z', 'Y', 'P'], ['P', 'C', 'Z']]
[['Z', 'C', 'Y'], ['Z', 'C', 'P'], ['Y', 'P', 'Z']]
[['Z', 'C', 'P'], ['Z', 'C', 'Y'], ['P', 'Y', 'Z']]
[['Z', 'C', 'Y'], ['Z', 'C', 'P'], ['P', 'Z', 'Y']]
[['Z', 'C', 'Y'], ['Z', 'C', 'Z'], ['P', 'Y', 'P']]
2
</code></pre></div></div>]]></content><author><name>Kim Boseong</name></author></entry><entry><title type="html"></title><link href="http://localhost:4000/2022-03-23-boj-12100/" rel="alternate" type="text/html" title="" /><published>2022-06-11T18:03:48+09:00</published><updated>2022-06-11T18:03:48+09:00</updated><id>http://localhost:4000/2022-03-23-boj-12100</id><content type="html" xml:base="http://localhost:4000/2022-03-23-boj-12100/"><![CDATA[<h1 id="백준-문제-중-12100번">백준 문제 중 12100번</h1>
<p><a>https://www.acmicpc.net/problem/12100</a></p>

<p>2048 게임은 4×4 크기의 보드에서 혼자 즐기는 재미있는 게임이다. 이 링크를 누르면 게임을 해볼 수 있다.</p>

<p>이 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 상하좌우 네 방향 중 하나로 이동시키는 것이다. 이때, 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. (실제 게임에서는 이동을 한 번 할 때마다 블록이 추가되지만, 이 문제에서 블록이 추가되는 경우는 없다)</p>

<h3 id="입력">입력</h3>

<p>첫째 줄에 보드의 크기 N (1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 게임판의 초기 상태가 주어진다. 0은 빈 칸을 나타내며, 이외의 값은 모두 블록을 나타낸다. 블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다. 블록은 적어도 하나 주어진다.</p>

<h3 id="출력">출력</h3>

<p>최대 5번 이동시켜서 얻을 수 있는 가장 큰 블록을 출력한다.</p>

<hr />

<h2 id="풀이">풀이</h2>

<p>처음에 문제에 접근 할때는 0이아닌 숫자가 있는 부분만 시작점으로 큐에 저장했다가 하나씩 꺼내서 한방향으로 모든 숫자를 이동하거나 병합하도록 진행하고 그 이후 남은 0이아닌 숫자를 큐에 넣어 BFS를 하는식으로 시도했었다.</p>

<p>그러나 코드를 짜다보니 맵 전체의 상태를 저장해야 될 필요성을 느꼈고 이동횟수가 5회로 제한되어 있으므로, 맵 전체를 입력 출력으로 하는 DFS를 하는게 더 나을 것 같다는 생각이 들었다.</p>

<p>여기 까지는 접근했으나 이동시 병합하거나 병합하지 않고 차례로 쌓는 처리가 너무 어려워서 검색을 통해 해결했다.</p>

<p>코드의 흐름은 이렇다.</p>
<ol>
  <li>현재 맵 상태를 입력으로 네 방향으로의 탐색을 재귀적으로 진행할 dfs를 호출한다.</li>
  <li>한 방향에 대하여 이동할때 조건에 따라 블럭들을 병합하거나, 블럭들을 순차적으로 쌓는 처리를 해줄 함수 move를 호출한다.</li>
  <li>move 함수는 움직이기전 상태의 맵을 입력받아 움직이고 난 후의 상태의 맵을 출력한다.(이때 반드시 깊은복사로 맵을 넘겨주어야 한다.)</li>
  <li>dfs의 탐색이 5회가 되면 가능한 최대값을 구한다.</li>
</ol>

<p>move 함수의 구현이 어려웠다. move 함수를 더 구체적으로 살펴보자<br />
 dir이 0인 경우 즉 위로 이동하는 경우라 가정하자.</p>
<ol>
  <li>맵을 각 col으로 쪼개 하나의 col마다 탐색을 진행하다.</li>
  <li>j번째 순차의 col의 가장 위를 기준으로 병합 및 저장이 시작되므로 열의 가장 윗 부분 row 인덱스인 0을 top에 저장한다.</li>
  <li>top이후의 인덱스 1부터 n-1을 i라 할때 차례대로 살펴보자.</li>
  <li>board[top][j]에 따라 top과 board[top][j]를 조작한다.
세가지의 동작이 있을 것이다.
    <ul>
      <li>board[top][j] == 0 이라면 board[i][j] 를 board[top][j]에 대입한다. top은 변동이 없다.</li>
      <li>board[top][j] == board[i][j] 라면 병합이 가능하므로 board[top][j]에 병합을 해주고 한 이동에 한번의 병합만이 가능하므로 기준 top의 인덱스를 1 증가 시킨다.</li>
      <li>둘다 아니라면 top의 인덱스를 1증가시키고 board[top][j]에 board[i][j]를 대입한다. (블럭이 쌓이는 경우)</li>
    </ul>
  </li>
</ol>

<p>이러한 과정을 각 방향에 대해 맞게끔 코드를 구성하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">board</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">board</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())))</span>


<span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="nb">dir</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">board</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span><span class="o">-&gt;</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>

     <span class="c1"># up
</span>    <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                    <span class="k">elif</span> <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">:</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="mi">2</span>
                        <span class="n">top</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">top</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> 
     <span class="c1"># right   
</span>    <span class="k">elif</span> <span class="nb">dir</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                    <span class="k">elif</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">:</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="mi">2</span>
                        <span class="n">top</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">top</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

     <span class="c1"># down
</span>    <span class="k">elif</span> <span class="nb">dir</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                    <span class="k">elif</span> <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">:</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="mi">2</span>
                        <span class="n">top</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">top</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

     <span class="c1"># left
</span>    <span class="k">elif</span> <span class="nb">dir</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                    <span class="k">elif</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">:</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="mi">2</span>
                        <span class="n">top</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">top</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="k">return</span> <span class="n">board</span>


<span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">cnt</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">int</span><span class="p">:</span>

    <span class="k">global</span> <span class="n">ans</span>

    <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span>

    <span class="n">dfs</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">board</span><span class="p">)),</span> <span class="n">cnt</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">board</span><span class="p">)),</span> <span class="n">cnt</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">board</span><span class="p">)),</span> <span class="n">cnt</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">board</span><span class="p">)),</span> <span class="n">cnt</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3
2 0 2
0 2 0
2 0 2
4
</code></pre></div></div>

<h3 id="배운점">배운점</h3>

<p>내가 슬라이싱 복사에 대해 잘못 알고 있어 헤맸던 부분이 있다. [:] 통한 객체 복사는 엄밀히 말하면 얕은 복사라는것이다. 처음에는 copy 모듈의 deepcopy가 아닌 슬라이싱 [:]을 통해 맵을 넘겨주었는데 굉장히 찾기 힘든 버그가 생겨서 해결하는데 시간이 오래결렸다.</p>

<p>다음을 살펴보자</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>

<span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">'True'</span><span class="p">)</span>
<span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">is</span> <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="k">print</span><span class="p">(</span><span class="s">'True'</span><span class="p">)</span>

<span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
True
[1, 2, 3, [4, 5, 6], 6]
</code></pre></div></div>

<p>a와 b의 id는 달라졌지만, 리스트 안의 리스트 즉 nested list는 얕은복사가 일어났음을 볼 수 있다.</p>]]></content><author><name>Kim Boseong</name></author></entry><entry><title type="html">Programmers, 코딩테스트 연습, 그리디, ‘조이스틱’</title><link href="http://localhost:4000/programmers/programmers-42860/" rel="alternate" type="text/html" title="Programmers, 코딩테스트 연습, 그리디, ‘조이스틱’" /><published>2022-06-07T00:00:00+09:00</published><updated>2022-06-07T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-42860</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-42860/"><![CDATA[<h1 id="프로그래머스-문제-중-조이스틱">프로그래머스 문제 중 ‘조이스틱’</h1>

<h3 id="문제설명">문제설명</h3>

<p>조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.
ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA</p>

<p>조이스틱을 각 방향으로 움직이면 아래와 같습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>▲ - 다음 알파벳
▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서)
</code></pre></div></div>

<p>예를 들어 아래의 방법으로 “JAZ”를 만들 수 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.
따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.
</code></pre></div></div>

<p>만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.</p>

<h3 id="제한사항">제한사항</h3>

<p>name은 알파벳 대문자로만 이루어져 있습니다.
name의 길이는 1 이상 20 이하입니다.</p>

<h3 id="입출력-예">입출력 예</h3>

<table>
  <thead>
    <tr>
      <th>name</th>
      <th>return</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“JEROEN”</td>
      <td>56</td>
    </tr>
    <tr>
      <td>“JAN”</td>
      <td>23</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="풀이">풀이</h2>

<p>level 2라 하기에는상당히 어려웠던 문제였다. 그리디로 분류되어 있지만 구현에 가까운 문제였던거 같다. 오랜시간 고민했지만 혼자 해결은 못했고, 다른 사람의 풀이를 참고했다.</p>

<p>주어진 입력을 최소한의 조작으로 원하는 문자열로 만들어야 한다. 문제를 읽으면 알 수 있듯 동작을 두개로 분리할 수 있다.</p>

<ol>
  <li>알파벳을 바꾸는 상하 동작</li>
  <li>다음으로 조작할 알파벳을 선택하는 좌우 동작</li>
</ol>

<p>1번의 상하의 동작은 어떤 순서로 알파벳을 선택하든 상하의 횟수가 변하지 않음을 알 수있다. 그러나 2번의 좌우의 동작은 알파벳의 배치에 따라 바뀔수 있으므로 알파벳을 선택하는 순서를 잘 고려해야 한다.</p>

<p>코드의 구성은 다음과 같다.</p>

<ol>
  <li>입력으로 주어진 name에 대해서 각 알파벳을 만드는데 필요한 최소의 값을 각각 구해 answer에 더해준다.</li>
  <li>좌우 동작이 최소인 경우를 구하기 위해 입력으로 주어진 name에 대해 모든 원소에 대해 최소한의 움직임으로 “A”가 아닌 모든 알파벳을 방문하는 횟수 move를 구한고 answer에 더해준다.</li>
</ol>

<p>2번의 동작에 대해 좀더 자세히 살펴보자</p>

<center>
  <img src="https://user-images.githubusercontent.com/94548914/172375288-2784c99e-0a2b-4ea9-916a-5a07697b8dc8.JPG" />
</center>

<p>name의 모든 요소에 대해 순차적으로 진행 하는데 이때 인덱스를 idx라 하자. 각 idx에 대하여 좌우로 움직여서 A가 아닌 모든 알파벳을 한번 이상 방문하는 것이 목표이다. 이 방문을 모든 idx에 대해 반복하고 각 idx 마다 움직인 거리의 총합, 즉 (idx: 0을 기준으로 현재 인덱스 까지의 거리, ((n - 1) - next_idx + 1): 0부터 왼쪽으로 A가 아닌 알파벳 까지 거리, distance: 왼쪽 오른쪽 중 더 짧은 거리)의 합과 기존의 move 중 최소의 값을 저장한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

     <span class="c1"># 알파벳을 바꾸는 상하 동작의 최솟값을 각각 answer에 더해줌
</span>    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"A"</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"Z"</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

     <span class="c1"># 자리를 바꾸는 좌우 동작의 총합 최솟값을 구해 answer에 더해줌
</span>    <span class="n">move</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">next_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">next_idx</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">next_idx</span><span class="p">]</span> <span class="o">==</span> <span class="s">'A'</span><span class="p">):</span>
            <span class="n">next_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">next_idx</span><span class="p">)</span>
        <span class="n">move</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">move</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">next_idx</span> <span class="o">+</span> <span class="n">distance</span><span class="p">)</span>

    <span class="n">answer</span> <span class="o">+=</span> <span class="n">move</span>
    <span class="k">print</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">answer</span>

<span class="n">solution</span><span class="p">(</span><span class="s">"JEROEN"</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Kim Boseong</name></author><category term="Programmers" /><category term="python" /><category term="프로그래머스" /><category term="코딩테스트" /><category term="그리디" /><summary type="html"><![CDATA[프로그래머스 문제 중 ‘조이스틱’]]></summary></entry><entry><title type="html">Programmers, 찾아라 프로그래밍 마에스터, 완전탐색, ‘게임 맵 최단거리’</title><link href="http://localhost:4000/programmers/programmers-1844/" rel="alternate" type="text/html" title="Programmers, 찾아라 프로그래밍 마에스터, 완전탐색, ‘게임 맵 최단거리’" /><published>2022-06-06T00:00:00+09:00</published><updated>2022-06-06T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-1844</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-1844/"><![CDATA[<h1 id="프로그래머스-문제-중-게임-맵-최단거리">프로그래머스 문제 중 ‘게임 맵 최단거리’</h1>

<h3 id="문제설명">문제설명</h3>

<p>ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.</p>

<p>지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.</p>

<center>
  <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dc3a1b49-13d3-4047-b6f8-6cc40b2702a7/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B51_sxuruo.png" width="30%" />
</center>

<p>위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.
아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.</p>

<ul>
  <li>첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.</li>
</ul>

<center>
  <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9d909e5a-ca95-4088-9df9-d84cb804b2b0/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B52_hnjd3b.png" width="30%" />
</center>

<ul>
  <li>두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.</li>
</ul>

<center>
  <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4b7cd629-a3c2-4e02-b748-a707211131de/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B53_ntxygd.png" width="30%" />
</center>

<p>위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.</p>

<p>만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.</p>

<center>
  <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d963b4bd-12e5-45da-9ca7-549e453d58a9/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B54_of9xfg.png" width="30%" />
</center>

<p>게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.</p>

<h3 id="제한사항">제한사항</h3>

<ul>
  <li>maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.
    <ul>
      <li>n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다.</li>
    </ul>
  </li>
  <li>maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.</li>
  <li>처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.</li>
</ul>

<h3 id="입출력-예">입출력 예</h3>

<table>
  <thead>
    <tr>
      <th>maps</th>
      <th>answer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]]</td>
      <td>11</td>
    </tr>
    <tr>
      <td>[[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]]</td>
      <td>-1</td>
    </tr>
  </tbody>
</table>

<h4 id="입출력-예-설명">입출력 예 설명</h4>

<h5 id="입출력-예-1">입출력 예 #1</h5>

<p>주어진 데이터는 다음과 같습니다.</p>

<center>
  <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/6db71f7f-58d3-4623-9fab-7cd99fa863a5/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B56_lgjvrb.png" width="30%" />
</center>

<p>캐릭터가 적 팀의 진영까지 이동하는 가장 빠른 길은 다음 그림과 같습니다.</p>

<center>
  <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d223d017-b3e2-4772-9045-a565133d45ff/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B52_hnjd3b%20%281%29.png" width="30%" />
</center>

<p>따라서 총 11칸을 캐릭터가 지나갔으므로 11을 return 하면 됩니다.</p>

<h5 id="입출력-예-2">입출력 예 #2</h5>

<p>문제의 예시와 같으며, 상대 팀 진영에 도달할 방법이 없습니다. 따라서 -1을 return 합니다.</p>

<hr />

<h2 id="풀이">풀이</h2>

<p>이전에 백준 사이트에서 다뤄봤던 <a href="https://bo-oseng.github.io/boj/boj-2178/">미로탐색</a>과 비슷한 문제였다. 미로탐색 문제를 풀면서 최단거리 탐색에 더 잘 어울리는 알고리즘은 BFS임을 학습했다.</p>

<p>DFS는 목적지까지 도착하는 것만이 목적이라 최단거리인지 아닌지를 판단하기 힘들고 모든 탐색의 경우를 다 끝내고 탐색을 마친 모든 경우를 각각을 비교하는 과정이 필요하다.</p>

<p>반면에 BFS는 모든 경우를 한칸씩 전진해 나가는 방식이므로 목적지에 도착만 한다면 그때 바로 최소값을 나타낸다.</p>

<p>따라서 이 문제는 BFS로 탐색을 진행하되, 주어지는 maps의 지형 중 도착이 불가능한 경우가 언제인지를 파악하는것이다.</p>

<p>도착이 불가능한 경우는 BFS로 가능한 모든 탐색을 진행 했음에도 [n - 1][m -1]에 도착하지 못하는 경우이다.</p>

<p>코드의 흐름은 다음과 같다.</p>

<ol>
  <li>방문여부 확인을 위한 2차원 리스트 visited를 선언한다.</li>
  <li>deque를 활용한 BFS탐색을 위한 함수 bfs를 선언한다.</li>
  <li>bfs는 deque를 활용해 구현하고, 상하좌우를 한칸씩 이동해보고 조건을 만족한다면 다음 탐색을 위해 칸의 수를 의미하는 cnt를 1증가시켜 큐에 넣고, 만족하지 못한다면 건너뛴다.</li>
  <li>bfs 탐색을 진행하던중 도착지에 도착한다면 바로 cnt를 return해준다.</li>
  <li>deque에 있는 모든 지점을 탐색했음에도 도착하지 못했다면 불가능한 경우 이므로 -1을 return한다.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">maps</span><span class="p">):</span>

    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">maps</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
     <span class="c1"># 상하좌우 탐색을 위한 dr, dc 선언
</span>    <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

     <span class="c1"># 방문여부 확인을 위한 visited 선언
</span>    <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
     <span class="c1"># 시작점 방문처리
</span>    <span class="n">visited</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

     <span class="c1"># 시작점의 정보를 start로 입력받는다.
</span>    <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
             <span class="c1"># 도착점에 있다면 cnt를 return한다.
</span>            <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cnt</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="ow">and</span> <span class="n">maps</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">visited</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="s">'''
     문제에 주어진 시작 좌표는 1,1 이나 0, 0에서 시작해
     n-1, m-1 도착으로 봐도 무방하다.
    '''</span>

     <span class="c1"># stat_cnt는 시작할때의 칸의 수이다.
</span>    <span class="n">start_r</span><span class="p">,</span> <span class="n">start_c</span><span class="p">,</span> <span class="n">start_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="n">bfs</span><span class="p">([</span><span class="n">start_r</span><span class="p">,</span> <span class="n">start_c</span><span class="p">,</span> <span class="n">start_cnt</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">answer</span>

<span class="n">solution</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11





11
</code></pre></div></div>]]></content><author><name>Kim Boseong</name></author><category term="Programmers" /><category term="python" /><category term="프로그래머스" /><category term="코딩테스트" /><category term="완전탐색" /><summary type="html"><![CDATA[프로그래머스 문제 중 ‘게임 맵 최단거리’]]></summary></entry><entry><title type="html">Programmers, 코딩테스트 연습, 완전탐색, ‘소수찾기’</title><link href="http://localhost:4000/programmers/programmers-42839/" rel="alternate" type="text/html" title="Programmers, 코딩테스트 연습, 완전탐색, ‘소수찾기’" /><published>2022-06-05T00:00:00+09:00</published><updated>2022-06-05T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-42839</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-42839/"><![CDATA[<h1 id="프로그래머스-문제-중-소수찾기">프로그래머스 문제 중 ‘소수찾기’</h1>

<h3 id="문제-설명">문제 설명</h3>

<p>한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.</p>

<p>각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.</p>

<h3 id="제한사항">제한사항</h3>

<ul>
  <li>numbers는 길이 1 이상 7 이하인 문자열입니다.</li>
  <li>numbers는 0~9까지 숫자만으로 이루어져 있습니다.</li>
  <li>“013”은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.</li>
</ul>

<h3 id="입출력-예">입출력 예</h3>

<table>
  <thead>
    <tr>
      <th>numbers</th>
      <th>return</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“17”</td>
      <td>3</td>
    </tr>
    <tr>
      <td>“011”</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<h4 id="입출력-예-설명">입출력 예 설명</h4>

<p>예제 #1
[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다.</p>

<p>예제 #2
[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다.</p>

<ul>
  <li>11과 011은 같은 숫자로 취급합니다.</li>
</ul>

<hr />

<h2 id="풀이">풀이</h2>

<p>이 문제는 파이썬의 기본 라이브러리로 제공되는 itertools 모듈의 permutaions과, set 자료형을 쓰면 쉽게 풀 수 있는 문제였다.</p>

<p>코드의 흐름은 다음과 같다.</p>

<ol>
  <li>에라스토의 체를 활용해 소수를 판별할 함수 is_prime을 선언한다.</li>
  <li>입력으로 주어진 numbers로 만든 수 있는 모든 경우를 tmp에 저장한다.</li>
  <li>string으로 저장된 tmp들을 join과 int 함수로 수들의 순열로 변환해 candidates에 저장한다.</li>
  <li>set으로 candidates의 중복을 제거하고, 이 후보들 중 소수의 개수를 찾는다.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>

 <span class="c1"># 에라스토의 체를 활용한 소수 판별
</span><span class="k">def</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
     <span class="c1"># 1 ~ n자리수까지 모두 가능하므로 모든 경우를 구한다.
</span>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">permutations</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

     <span class="c1"># 문자열 튜플들로 이루어진 리스트 tmp의 값들을 조작한다.
</span>    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
        <span class="n">candidates</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

     <span class="c1"># set 자료형으로 후보의 중복을 제거하고, 소수를 판별한다.
</span>    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">answer</span>

<span class="n">solution</span><span class="p">(</span><span class="s">"011"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>101
11






2
</code></pre></div></div>

<h2 id="배운점">배운점</h2>

<p>가장 좋아요를 많이 받은 풀이를 보고 배웠던 건 set자료형의 연산과 활용이다. 항상 set자료형은 간단히 중복제거에만 쓰고 더 활용 해보지 않았는데 이 풀이는 set 자료형의 연산으로 합집합, 차집합을 활용했다. 그래서 set 자료형의 연산을 정리했다.</p>

<ol>
  <li>합집합 연산</li>
</ol>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>연산자를 통해 A</td>
          <td>B 는 합집합을 나타낸다.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<ol>
  <li>교집합 연산</li>
</ol>

<ul>
  <li>&amp; 연산자를 통해 A &amp; B 는 교집합을 나타낸다.</li>
</ul>

<ol>
  <li>차집합 연산</li>
</ol>

<ul>
  <li>- 연산자를 통해 A - B 는 차집합을 나타낸다.</li>
</ul>

<ol>
  <li>대칭 차집합 연산(합집합에서 교집합을 뺀것)</li>
</ol>

<ul>
  <li>^ 연산자를 통해 A ^ B 는 대칭 차집합을 나타낸다.</li>
</ul>]]></content><author><name>Kim Boseong</name></author><category term="Programmers" /><category term="python" /><category term="프로그래머스" /><category term="코딩테스트" /><category term="완전탐색" /><summary type="html"><![CDATA[프로그래머스 문제 중 ‘소수찾기’]]></summary></entry><entry><title type="html">API authentication by API key, API key로 API 인증하기</title><link href="http://localhost:4000/http/web-api_key_access/" rel="alternate" type="text/html" title="API authentication by API key, API key로 API 인증하기" /><published>2022-05-23T00:00:00+09:00</published><updated>2022-05-23T00:00:00+09:00</updated><id>http://localhost:4000/http/web-api_key_access</id><content type="html" xml:base="http://localhost:4000/http/web-api_key_access/"><![CDATA[<h1 id="api-key-access">API key access</h1>

<h3 id="배경">배경</h3>

<p>최근 Vanila Javascript 예제를 몇개 만들어 보고 있는데, <a href="https://github.com/bo-oseng/vanilla_javascript_pratice_projects/tree/main/Exchange%20Rate%20Calculator">Exachange Rate Calculator</a> 에서 API를 다룬적이 있습니다. API를 써본적은 있었지만 API로의 접근에서 권한을 필요로 하는 API는 처음 만나게 되었습니다. <a href="https://apilayer.com/marketplace/description/exchangerates_data-api?preview=true#documentation-tab">API를 제공하는 사이트의 스펙</a>에서 사용법과 API key를 친절히 제공해 주어 쉽게 다룰 수 있었지만 어떤 원리로 권한을 인가받고 API key은 어떻게 생성되는지 또 이 과정에서 쓰이는 Header의 정체 무엇인지 궁금해 추가적으로 조사하고 정리한 글 입니다.</p>

<h3 id="사전지식-정리">사전지식 정리</h3>

<ol>
  <li>
    <p>Authentication(인증)과 Authorization(인가)의 차이</p>

    <p>Authentication(인증): 접근하는 유저의 신원을 확인하고 통과 시킬지 확인하는 절차.</p>

    <p>Authorization(인가): 접근하는 유저가 무엇을 할 수 있는지 권한을 허락하는 것.</p>

    <p>서비스를 누가 언제 어떻게 얼마나 쓰고 있는지를 추적하기 위해 반드시 필요하다.</p>
  </li>
  <li>
    <p>HTTP headers</p>

    <p>HTTP 헤더는 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해준다.</p>

    <p>소프트웨어 정보, 쿠키, 문자포멧등을 담고 있다.</p>
  </li>
  <li>
    <p>Headers 객체</p>

    <p>fetch 함수에서 api를 요청할때 header를 다룰수 있게 하는 인터페이스 이다.
(참고: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MDN</a>)</p>
  </li>
</ol>

<h3 id="api-authentication인증의-대표적인-방법들">API authentication(인증)의 대표적인 방법들</h3>

<ul>
  <li>HTTP Basic Authentication</li>
  <li>OAuth 2.0 (Token in HTTP Header)</li>
  <li>
    <p>API Keys</p>

    <p>API 인증에 쓰이는 방법은 대표적으로 위의 세가지가 있고, 이 중 API key방식에 대해 알아 보겠습니다.</p>
  </li>
</ul>

<h2 id="api-key">API key</h2>

<p><a href="https://cloud.google.com/endpoints/docs/openapi/when-why-api-key?hl=ko#:~:text=API%20%ED%82%A4%EB%8A%94%20%EC%9D%B8%EC%A6%9D%20%ED%86%A0%ED%81%B0,%EC%9D%84%20%EC%A0%9C%ED%95%9C%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.">구글 클라우드 문서</a>를 참고했습니다.</p>

<p>API key는 구글 클라우드 문서에서 제공한 사진을 보고 쉽게 이해 할 수 있었습니다.</p>

<center>
  <img src="https://cloud.google.com/endpoints/docs/images/api_keys_overview.png?hl=ko" width="50%" />
</center>

<p>사진에서 알 수 있듯 사용가 API를 요청할때 API 서비스 제공자에게 발급받은 API key를 헤더에 함께 보내면 제공자가 사용자를 인지하고 유효한 키라면 사용을 허가합니다.</p>

<p>API key를 이용하는 방식은 다음과 같은 특징이 있습니다.</p>

<ul>
  <li>API key를 발급받은 유저의 API 사용량을 체크 할 수 있습니다.</li>
  <li>API를 호출하는 애플리케이션이나 프로젝트를 식별합니다. 호출을 특정 IP 주소 범위, Android 앱, iOS 앱과 같은 환경에서의 키 사용을 제한할 수 있습니다.</li>
  <li>프로젝트를 식별할 뿐사용자를 구별하여 식별하지는 않습니다.</li>
</ul>

<p>이런 특징들 때문에 API 사용량에 따른 요금부과가 가능하고, DDOS 공격으로 부터 서비스를 보호할 수 있습니다.<br />
그래서 사용량으로 사용자에게 요금을 책정하는 API 제공 서비스들이 많이 채택하고 있는 방식 입니다.</p>

<h2 id="api-key-사용법">API key 사용법</h2>

<p>fetch()함수에서 API key를 사용하는 방법은 다음과 같습니다.</p>

<ol>
  <li>서비스 제공자로부터 API key를 발급 받는다.</li>
  <li>fetch() 함수의 두번째 파라미터 내부의 header 객체에 apikey의 정보가 포함시켜 호출한다.</li>
</ol>

<p>다음 예시를 보면 쉽게 알 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">calculate</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">currency_one</span> <span class="o">=</span> <span class="nx">currencyEl_one</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">currency_two</span> <span class="o">=</span> <span class="nx">currencyEl_two</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>

  <span class="c1">// 새로운 Headers객체 선언</span>
  <span class="kd">let</span> <span class="nx">myHeaders</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Headers</span><span class="p">();</span>
  <span class="c1">// Headers 객체에 apikey프로퍼티와 서비스 제공자로부터 발급 받은 키값을 넣어줌</span>
  <span class="nx">myHeaders</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="dl">"</span><span class="s2">apikey</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">pm6pDh9DAXyiCVOuIesoQJLQZwQ6****</span><span class="dl">"</span><span class="p">);</span>

  <span class="c1">// fetch의 요청 방식과 헤더를 포함한 requestOptions 객체선언</span>
  <span class="kd">let</span> <span class="nx">requestOptions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">GET</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="nx">myHeaders</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">// fetch함수의 첫번째 파라미터로 API의 주소, 두번쨰 파라미터로 요청에 대한 추가 데이터를 전달해줌</span>
  <span class="nx">fetch</span><span class="p">(</span>
    <span class="s2">`https://api.apilayer.com/exchangerates_data/latest?symbols=</span><span class="p">${</span><span class="nx">currency_two</span><span class="p">}</span><span class="s2">&amp;base=</span><span class="p">${</span><span class="nx">currency_one</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="nx">requestOptions</span>
  <span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">rate</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">rates</span><span class="p">[</span><span class="nx">currency_two</span><span class="p">];</span>

      <span class="nx">rateEl</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="s2">`1 </span><span class="p">${</span><span class="nx">currency_one</span><span class="p">}</span><span class="s2"> = </span><span class="p">${</span><span class="nx">rate</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">currency_two</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

      <span class="nx">amountEl_two</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="p">(</span><span class="nx">amountEl_one</span><span class="p">.</span><span class="nx">value</span> <span class="o">*</span> <span class="nx">rate</span><span class="p">).</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="참고">참고</h4>

<blockquote>
  <p>잘못된 정보가 포함되어 있을 수 있습니다.</p>

  <p>다음에는 카카오 로그인이나 구글 로그인에 활용 되는 OAuth에 대해 알아보겠 습니다.</p>
</blockquote>]]></content><author><name>Kim Boseong</name></author><category term="[&quot;HTTP&quot;]" /><category term="authentication" /><category term="authorization" /><category term="headers" /><category term="Web" /><summary type="html"><![CDATA[API key access]]></summary></entry><entry><title type="html">Programmers, 코딩테스트 연습, 스택/큐, ‘가장 큰 수’</title><link href="http://localhost:4000/programmers/programmer-42746/" rel="alternate" type="text/html" title="Programmers, 코딩테스트 연습, 스택/큐, ‘가장 큰 수’" /><published>2022-05-22T00:00:00+09:00</published><updated>2022-05-22T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmer-42746</id><content type="html" xml:base="http://localhost:4000/programmers/programmer-42746/"><![CDATA[<h1 id="프로그래머스-문제-중-42746번-가장-큰-수">프로그래머스 문제 중 42746번 ‘가장 큰 수’</h1>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/42746">https://programmers.co.kr/learn/courses/30/lessons/42746</a></p>

<h3 id="문제-설명">문제 설명</h3>

<p>0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.</p>

<p>예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.</p>

<p>0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.</p>

<h3 id="제한사항">제한사항</h3>

<ul>
  <li>numbers의 길이는 1 이상 100,000 이하입니다.</li>
  <li>numbers의 원소는 0 이상 1,000 이하입니다.</li>
  <li>정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.</li>
</ul>

<h3 id="입출력-예">입출력 예</h3>

<table>
  <thead>
    <tr>
      <th>numbers</th>
      <th>return</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[6, 10, 2]</td>
      <td>“6210”</td>
    </tr>
    <tr>
      <td>[3, 30, 34, 5, 9]</td>
      <td>“9534330”</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="풀이">풀이</h2>

<h4 id="try1">Try1</h4>

<p>처음 문제에 접근할때는 단순하게 모든 경우를 따져 보면 될것 같아서 itertools 모듈의 permutations으로 문제에 접근했으나 시간초과가 떴다.</p>

<p>이 문제를 접하기 전까지만 해도 파이썬 내부모듈의 효율에 대해 확신을 가지고 있었다.</p>

<p>하지만 검색을 해보니 premutations의 시간 복잡도는 O(n^r)로 알고리즘의 효율을 위해서는 지양해야할 모듈이란걸 알게 되었다.</p>

<p><a href="https://stackoverflow.com/questions/58677464/big-o-notation-of-the-permutation-algorithm-in-python-itertools-permutation">permutation의 시간복잡도 참고</a></p>

<p>주어진 numbers를 str로 바꾸고 모든 수열에 대해 최대값을 찾는 식으로 코드를 구현했고, 답을 맞지만 시간초과가 떴다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
    <span class="n">max_tmp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">candidataes</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">numbers</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>
    <span class="c1"># 가능한 모든 경우의 수열에 대해 tmp의 크기를 비교해봄
</span>    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidataes</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="n">max_tmp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_tmp</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_tmp</span><span class="p">)</span>

<span class="n">solution</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'6210'
</code></pre></div></div>

<p>시간초과를 해결하기 위해서는 단순 비교하는 하드코딩이 아닌 더 효율적인 방법이 필요했다.</p>

<h4 id="try2">Try2</h4>

<p>자바스크립트의 기능 중 sort(compare_func)에 쓰이는 비교함수 compare_func 같은 기능이 파이썬에도 있지 않을까 검색을 , functools의 cmp_to_key 모듈로 javascript의 compare_func과 동일한 방법으로 구현이 가능함을 알게되었다.</p>

<p>cmp_to_key에 대해 간략히 설명하자면 배열에서 차례대로 cmp_to_key(element1, element2)에 두개의 인자가 주어지고, element1과 element2으로 이루어진 return이 True라면 element1과 element2의 위치를 바꾸고 False라면 위치를 바꾸지 않는다.</p>

<p>그리고 수가 0보다 크면 True를 나타내고, 0이거나 0보다 작으면 False를 나타내는 특성을 이용하면 쉽게 비교함수 cmp_to_key를 다룰 수 있다.</p>

<p><a href="https://docs.python.org/ko/3/library/functools.html#functools.cmp_to_key">functools.cmp_to_key 참고자료</a></p>

<p>이 문제에서는 조합시 더 큰 값을 가지게끔 배열을 정렬해야하므로</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp1</span> <span class="o">-</span> <span class="n">tmp2</span>
</code></pre></div></div>

<p>과 같이 비교함수를 구현했다.</p>

<p>비교함수를 통해 새로 만든 배열을 맨끝부터 차례로 이어 붙이면 만들 수 있는 최대의 수를 나타낸다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cmp_to_key</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
     <span class="c1"># 조합했을 때 더 큰값이 가지는 순으로 정렬
</span>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">element1</span><span class="p">,</span> <span class="n">element2</span><span class="p">):</span>
        <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">element1</span> <span class="o">+</span> <span class="n">element2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">element2</span> <span class="o">+</span> <span class="n">element1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp1</span> <span class="o">-</span> <span class="n">tmp2</span>
     <span class="c1"># sorted의 key=cmp_to_key(비교함수) 인자를 주면 비교함수를 사용할 수 있다.
</span>    <span class="n">str_numbers</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">numbers</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">cmp_to_key</span><span class="p">(</span><span class="n">compare</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">str_numbers</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="s">''</span>
    <span class="k">while</span> <span class="n">str_numbers</span><span class="p">:</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="n">str_numbers</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">answer</span><span class="p">))</span>


<span class="k">print</span><span class="p">(</span><span class="n">solution</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">89</span><span class="p">]))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['8', '89', '98', '9']
998898
</code></pre></div></div>]]></content><author><name>Kim Boseong</name></author><category term="Programmers" /><category term="python" /><category term="프로그래머스" /><category term="코딩테스트" /><category term="스택" /><category term="functools.cmp_to_key" /><summary type="html"><![CDATA[프로그래머스 문제 중 42746번 ‘가장 큰 수’]]></summary></entry><entry><title type="html">Programmers, 코딩테스트 연습, 해시, ‘전화번호 목록’</title><link href="http://localhost:4000/programmers/programmer-42577/" rel="alternate" type="text/html" title="Programmers, 코딩테스트 연습, 해시, ‘전화번호 목록’" /><published>2022-05-20T00:00:00+09:00</published><updated>2022-05-20T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmer-42577</id><content type="html" xml:base="http://localhost:4000/programmers/programmer-42577/"><![CDATA[<h1 id="프로그래머스-문제-중-42577번-전화번호-목록">프로그래머스 문제 중 42577번 ‘전화번호 목록’</h1>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/42577">https://programmers.co.kr/learn/courses/30/lessons/42577</a></p>

<h3 id="문제설명">문제설명</h3>

<p>전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.</p>

<ul>
  <li>구조대 : 119</li>
  <li>박준영 : 97 674 223</li>
  <li>지영석 : 11 9552 4421</li>
</ul>

<p>전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.</p>

<h3 id="제한사항">제한사항</h3>

<ul>
  <li>phone_book의 길이는 1 이상 1,000,000 이하입니다.
    <ul>
      <li>각 전화번호의 길이는 1 이상 20 이하입니다.</li>
      <li>같은 전화번호가 중복해서 들어있지 않습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="입출력-예">입출력 예</h3>

<table>
  <thead>
    <tr>
      <th>phone_book</th>
      <th>return</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[“119”, “97674223”, “1195524421”]</td>
      <td>false</td>
    </tr>
    <tr>
      <td>[“123”,”456”,”789”]</td>
      <td>true</td>
    </tr>
    <tr>
      <td>[“12”,”123”,”1235”,”567”,”88”]</td>
      <td>false</td>
    </tr>
  </tbody>
</table>

<h3 id="입출력-예-설명">입출력 예 설명</h3>

<h4 id="입출력-예-1">입출력 예 #1</h4>

<p>앞에서 설명한 예와 같습니다.</p>

<h4 id="입출력-예-2">입출력 예 #2</h4>

<p>한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.</p>

<h4 id="입출력-예-3">입출력 예 #3</h4>

<p>첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.</p>

<hr />
<h2 id="풀이">풀이</h2>

<p>해시로 접근해야 효율성 테스트에서 통과할 수 있었던 문제였다. 아무래도 단원 이름에 해쉬가 없었다면 헤맸을것 같은 문제이다.</p>

<p>코드의 구성은 다음과 같다.</p>

<ol>
  <li>입력으로 주어진 phone_book을 키로 가지는 해쉬를 선언한다.</li>
  <li>입력으로 주어진 phone_book의 원소를 각 phone_num이라 할때 phone_num 을 한글자씩 꺼내 tmp에 더해나가며 tmp가 해쉬테이블의 키로 존재하는지 비교하고, tmp가 phone_num 자체가 아니라면 해당 해쉬테이블의 키가 tmp를 접두어로 가지므로 False 를 반환한다.</li>
  <li>모든 스캔을 종료하면 접두어가 없으므로 True를 반환한다.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">phone_book</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">phone_num</span><span class="p">:</span><span class="mi">1</span> <span class="k">for</span> <span class="n">phone_num</span> <span class="ow">in</span> <span class="n">phone_book</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">phone_num</span> <span class="ow">in</span> <span class="n">phone_book</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="s">''</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">phone_num</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">num</span>
            <span class="k">if</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="n">d</span><span class="p">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">phone_num</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>]]></content><author><name>Kim Boseong</name></author><category term="Programmers" /><category term="python" /><category term="프로그래머스" /><category term="코딩테스트" /><category term="해시" /><summary type="html"><![CDATA[프로그래머스 문제 중 42577번 ‘전화번호 목록’]]></summary></entry><entry><title type="html">Programmers, 월간 코드 챌린지 시즌3, 구현, DFS/BFS, ‘빛의 경로 사이클’</title><link href="http://localhost:4000/programmers/programmer-86052/" rel="alternate" type="text/html" title="Programmers, 월간 코드 챌린지 시즌3, 구현, DFS/BFS, ‘빛의 경로 사이클’" /><published>2022-05-19T00:00:00+09:00</published><updated>2022-05-19T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmer-86052</id><content type="html" xml:base="http://localhost:4000/programmers/programmer-86052/"><![CDATA[<h1 id="프로그래머스-문제-중-86052번-빛의-경로-사이클">프로그래머스 문제 중 86052번 ‘빛의 경로 사이클’</h1>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/86052">https://programmers.co.kr/learn/courses/30/lessons/86052</a></p>

<h3 id="문제설명">문제설명</h3>

<p>각 칸마다 S, L, 또는 R가 써져 있는 격자가 있습니다. 당신은 이 격자에서 빛을 쏘고자 합니다. 이 격자의 각 칸에는 다음과 같은 특이한 성질이 있습니다.</p>

<ul>
  <li>빛이 “S”가 써진 칸에 도달한 경우, 직진합니다.</li>
  <li>빛이 “L”이 써진 칸에 도달한 경우, 좌회전을 합니다.</li>
  <li>빛이 “R”이 써진 칸에 도달한 경우, 우회전을 합니다.</li>
  <li>빛이 격자의 끝을 넘어갈 경우, 반대쪽 끝으로 다시 돌아옵니다. 예를 들어, 빛이 1행에서 행이 줄어드는 방향으로 이동할 경우, 같은 열의 반대쪽 끝 행으로 다시 돌아옵니다.</li>
</ul>

<p>당신은 이 격자 내에서 빛이 이동할 수 있는 경로 사이클이 몇 개 있고, 각 사이클의 길이가 얼마인지 알고 싶습니다. 경로 사이클이란, 빛이 이동하는 순환 경로를 의미합니다.</p>

<p>예를 들어, 다음 그림은 격자 [“SL”,”LR”]에서 1행 1열에서 2행 1열 방향으로 빛을 쏠 경우, 해당 빛이 이동하는 경로 사이클을 표현한 것입니다.</p>

<center>
  <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/f3c02c50-f82e-45d0-b633-ad3ecadba316/ex1.png" width="50%" />
</center>

<p>이 격자에는 길이가 16인 사이클 1개가 있으며, 다른 사이클은 존재하지 않습니다.</p>

<p>격자의 정보를 나타내는 1차원 문자열 배열 grid가 매개변수로 주어집니다. 주어진 격자를 통해 만들어지는 빛의 경로 사이클의 모든 길이들을 배열에 담아 오름차순으로 정렬하여 return 하도록 solution 함수를 완성해주세요.</p>

<h4 id="제한사항">제한사항</h4>

<ul>
  <li>1 ≤ grid의 길이 ≤ 500
    <ul>
      <li>1 ≤ grid의 각 문자열의 길이 ≤ 500</li>
      <li>grid의 모든 문자열의 길이는 서로 같습니다.</li>
      <li>grid의 모든 문자열은 ‘L’, ‘R’, ‘S’로 이루어져 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="입출력의-예">입출력의 예</h3>

<table>
  <thead>
    <tr>
      <th>grid</th>
      <th>results</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[“SL”,”LR”]</td>
      <td>[16]</td>
    </tr>
    <tr>
      <td>[“S”]</td>
      <td>[1,1,1,1]</td>
    </tr>
    <tr>
      <td>[“R”,”R”]</td>
      <td>[4,4]</td>
    </tr>
  </tbody>
</table>

<h3 id="입출력-예-설명">입출력 예 설명</h3>

<h4 id="입출력-예-1">입출력 예 #1</h4>

<ul>
  <li>문제 예시와 같습니다.</li>
  <li>길이가 16인 사이클이 하나 존재하므로(다른 사이클은 없습니다.), [16]을 return 해야 합니다.</li>
</ul>

<h4 id="입출력-예-2">입출력 예 #2</h4>

<center> 
  <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/88a2717d-14ab-4297-af06-00baab718080/ex2.png" width="50%" />
</center>

<ul>
  <li>4개의 사이클의 길이가 모두 1이므로, [1,1,1,1]을 return 해야 합니다.</li>
</ul>

<h4 id="입출력-예--4">입출력 예 # 4</h4>

<ul>
  <li>주어진 격자를 통해 만들 수 있는 사이클들은 다음 그림과 같습니다.</li>
</ul>
<center>
 <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/076dbe07-2b33-414e-b6db-1e73ae2055f3/ex3.png" width="50%" />
</center>

<hr />

<h5 id="참고">참고</h5>

<p>문제가 조금 불친절 했던것 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>예를 들어, 다음 그림은 격자 ["SL","LR"]에서
1행 1열에서 2행 1열 방향으로 빛을 쏠 경우,
해당 빛이 이동하는 경로 사이클을 표현한 것입니다.
</code></pre></div></div>

<p>이 부분에서 오해가 생겼는데 시작점은 1행 1열이고 쏘는 방향만 달라지는 문제라고 생각하게 되었다. 예제로 주어진 입출력도 공교롭게 모두 1행 1열에서 시작되는 경우만 주어져서 오류를 해결하는데 시간이 오래 걸렸었다. 심지어 문제를 제대로 이해하고, 접근했어도 꽤나 어려웠던 문제였다.</p>

<hr />

<h2 id="풀이">풀이</h2>

<p>이 문제는 완전탐색을 이용해 접근해야 하는데 한가지 특이한점이 있다. 탐색을 하는 부분이 순환을 하는지 여부를 알아야 하는데, 순환을 한다면 탐색을 언제 어떻게 종료해야 하는지를 고려해야하고 이 부분이 문제의 핵심이다.</p>

<ul>
  <li>
    <p>각 노드마다 해당 노드에서 출발하는 방향은 상, 하, 좌, 우로 총 네가지만이 존재하고 만약 이번 탐색에 해당 노드에서 상으로 나간 방향이 돌고돌아 다시 해당 노드로 돌아와 다시 상 방향으로 나가게 된다면 순환을 판별할 수 있다.</p>
  </li>
  <li>
    <p>또한 해당노드로 들어오는 빛의 각 방향에 대하여 다음 빛의 방향이 단 한가지의 방향으로 결정된다. 다음 빛의 방향이 정해지므로 만약 해당노드에서 특정방향으로 쏘아진 빛이 순환한다면, 그 순환이 갖는 노드와 방향에 대한 정보는 순서에 상관없이 단 한개의 순환을 나타낸다.</p>
  </li>
</ul>

<p>그러므로 해당노드에서 4가지의 방향으로 빛이 쏘아진 적이 있는지 체크하는 리스트 visited를 선언하고, 모든 노드와 방향에 대해 visited를 기준으로 탐색을 진행하면 된다.</p>

<p>코드의 흐름은 다음과 같다.</p>

<ol>
  <li>상, 하, 좌, 우 순으로 각 방향을 ` dir_dict = {0: (-1, 0), 1: (0, 1), 2: (1, 0), 3: (0, -1)}` 처럼 딕셔너리 형태로 선언한다.</li>
  <li>다음으로 진행할 노드의 좌표와 진행중인 방향을 입력받아 다음 방향을 설정해줄 함수 <code class="language-plaintext highlighter-rouge">next_dir(next_row, next_col, direction_number):</code>을 선언한다. (음수의 % 연산을 양수로 바꿔주는 파이썬의 특성을 활용하면 쉽게 조작할 수 있다.)</li>
  <li>각노드에 대해 네가지 방향의 방문을 확인할 <code class="language-plaintext highlighter-rouge">visited = [[[False] * 4 for _ in range(m)] for _ in range(n)]</code> 리스를 선언한다.</li>
  <li>모든 노드와 모든 방향에 대해서 탐색을 진행하는데, 새로운 노드와 방향을 방문할때마다 cnt를 1 증가시켜준다.</li>
  <li>탐색중 visited가 true 부분을 만난다면, 시작점과 종료점이 같은지 확인하고 같다면 하나의 순환이 완성 됐으므로 순환의 길이를 나타내는 cnt를 answer에 추가해준다.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
     <span class="c1"># 각 방향을 수로 나타낼 딕셔너리 선언
</span>    <span class="n">dir_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)}</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

     <span class="c1"># 현재 진행중인 방향과 다음 노드의 좌표를 입력받아 다음 방향을 설정하는 함수
</span>    <span class="k">def</span> <span class="nf">next_dir</span><span class="p">(</span><span class="n">next_row</span><span class="p">,</span> <span class="n">next_col</span><span class="p">,</span> <span class="n">direction_number</span><span class="p">):</span>
        <span class="n">next_dir_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">next_row</span><span class="p">][</span><span class="n">next_col</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s">'S'</span><span class="p">:</span>
            <span class="n">next_dir_num</span> <span class="o">=</span> <span class="n">direction_number</span>
        <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s">'L'</span><span class="p">:</span>
            <span class="n">next_dir_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s">'R'</span><span class="p">:</span>
            <span class="n">next_dir_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
        <span class="k">return</span> <span class="n">next_dir_num</span>

    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
     <span class="c1"># 각 노드에 대해 4가지의 방향을 확인할 리스트 선언
</span>    <span class="n">visited</span> <span class="o">=</span> <span class="p">[[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">][</span><span class="n">num</span><span class="p">]:</span>
                    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">visited</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">][</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">stk</span> <span class="o">=</span> <span class="p">[[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">num</span><span class="p">]]</span>
                    <span class="k">while</span> <span class="n">stk</span><span class="p">:</span>
                        <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">dir_dict</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">dir_dict</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="n">m</span>
                        <span class="n">nd</span> <span class="o">=</span> <span class="n">next_dir</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">][</span><span class="n">nd</span><span class="p">]:</span>
                            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">][</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="n">stk</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nd</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># visited가 True라면 순환의 시작점과 종료점이 같은지 확인
</span>                            <span class="c1"># 같다면 answer에 순환의 길이를 나타내는 cnt를 추가
</span>                            <span class="k">if</span> <span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">nd</span><span class="p">]:</span>
                                <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
<span class="n">solution</span><span class="p">([</span><span class="s">"SL"</span><span class="p">,</span><span class="s">"LR"</span><span class="p">])</span>
</code></pre></div></div>]]></content><author><name>Kim Boseong</name></author><category term="Programmers" /><category term="python" /><category term="프로그래머스" /><category term="코딩테스트" /><category term="구현" /><category term="DFS/BFS" /><summary type="html"><![CDATA[프로그래머스 문제 중 86052번 ‘빛의 경로 사이클’]]></summary></entry><entry><title type="html">Programmers, 2020 카카오 인턴쉽, 스택, ‘수식 최대화’</title><link href="http://localhost:4000/programmers/programmers-67257/" rel="alternate" type="text/html" title="Programmers, 2020 카카오 인턴쉽, 스택, ‘수식 최대화’" /><published>2022-05-17T00:00:00+09:00</published><updated>2022-05-17T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-67257</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-67257/"><![CDATA[<h1 id="프로그래머스-문제-중-67257번-수식-최대화">프로그래머스 문제 중 67257번 ‘수식 최대화’</h1>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/67257">https://programmers.co.kr/learn/courses/30/lessons/67257</a></p>

<h3 id="문제설명">문제설명</h3>

<p>IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.
이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.
해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, <em>) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.
단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,</em> &gt; - 또는 * &gt; +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.
만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.</p>

<p>예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"100-200*300-500+20"
</code></pre></div></div>

<p>일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * &gt; +,- 로 우선순위가 정의되어 있습니다.
대회 규칙에 따라 + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.
수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + &gt; - &gt; * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.
반면에 * &gt; + &gt; - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.</p>

<p>참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.</p>

<h3 id="제한사항">제한사항</h3>

<ul>
  <li>expression은 길이가 3 이상 100 이하인 문자열입니다.</li>
  <li>expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.
    <ul>
      <li>즉, “402+-561*“처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.</li>
    </ul>
  </li>
  <li>expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.
즉, “100-2145*458+12”처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.
“-56+100”처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.</li>
  <li>expression은 적어도 1개 이상의 연산자를 포함하고 있습니다.</li>
  <li>연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다.</li>
  <li>같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.</li>
</ul>

<h3 id="입출력-예">입출력 예</h3>

<table>
  <thead>
    <tr>
      <th>expression</th>
      <th>result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“100-200*300-500+20”</td>
      <td>60420</td>
    </tr>
    <tr>
      <td>“50<em>6-3</em>2”</td>
      <td>300</td>
    </tr>
  </tbody>
</table>

<h3 id="입출력-예에-대한-설명">입출력 예에 대한 설명</h3>

<h4 id="입출력-예--1">입출력 예 # 1</h4>

<p><code class="language-plaintext highlighter-rouge">* &gt; + &gt; -</code>로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.
연산 순서는 아래와 같습니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>100-200*300-500+20
= 100-(200*300)-500+20
= 100-60000-(500+20)
= (100-60000)-520
= (-59900-520)
= -60420
</code></pre></div></div>
<p>따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다.</p>

<h4 id="입출력-예-2">입출력 예 #2</h4>

<p><code class="language-plaintext highlighter-rouge">- &gt; *</code>로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.
연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>50*6-3*2
= 50*(6-3)*2
= (50*3)*2
= 150*2
= 300
</code></pre></div></div>
<p>따라서, 우승 시 받을 수 있는 상금은 300 입니다.</p>

<hr />

<h2 id="풀이">풀이</h2>

<p>연산에 우선순위가 있는 스택 문제로 비슷한 접근법인 <a href="https://bo-oseng.github.io/boj/boj-1918/">후위 표기식</a>의 Try2 부분을 이전에 다뤄 본적이 있어서 비슷한 방법으로 접근 할 수 있었다. 처음 접했다면 매우 어려웠을 것 같은 문제이다.</p>

<p>먼저 쉽게 풀어 쓰자면, 입력으로 주어진 문자열을 앞에서부터 차례로 스캔하며 연산자들의 스택에 집어 넣다가, 연산 우선순위가 낮은 연산은 나중에 해도 되므로 스택에 남겨 두고, 우선순위가 더 높은 연산자는 다음으로 올 연산자 보다 먼저 계산 해야 하므로 <code class="language-plaintext highlighter-rouge">( )</code>을 쳐서 연산을 먼저 하는 것처럼 미리 처리를 해준다고 생각하면 된다.</p>

<p>접근법 중 우선순위에 맞게 계산하는 방법을 요약 하자면 다음과 같다.</p>
<ol>
  <li>연산의 우선순위를 정한다. ( ex) <code class="language-plaintext highlighter-rouge">p = {'+': 1, '-': 2, '*': 3}</code>)</li>
  <li>입력으로 주어진 문자열을 처음부터 차레로 스캔하는데 연산자가 아닌 숫자 문자열 이라면 tmp에 저장한다.</li>
  <li>입력으로 주어진 문자열을 처음부터 차례로 스캔하며 연산자를 만났을때를 분기로 동작한다. (이때 현재 스캔중인 문자를 e라고 하자)</li>
  <li>tmp에 저장된 숫자 문자열을 스택 operands에 저장하고, tmp를 ‘‘로 초기화 한다.</li>
  <li>스택 operators가 비었다면 연산자 e를 스택에 넣는다.</li>
  <li>operators의 가장 마지막 원소의 우선순위보다 e의 우선순위가 높다면 (<code class="language-plaintext highlighter-rouge">p[operators[-1]] &gt;= p[e]</code>) operators가 존재하며, <code class="language-plaintext highlighter-rouge">p[operators[-1]] &gt;= p[e]</code> 동안 스택을 비우며 연산을 진행한다.</li>
  <li>연산이 끝나면 operators에 e를 추가한다.</li>
  <li>스캔이 모두 종료되고 나면 연산자를 만나기 전의 tmp가 남아있으므로 tmp를 operands에 저장하고, operators 스택이 빌때까지 모든 연산을 진행한다.</li>
</ol>

<p>글로 쓰여 있는것만 봐서는 이해가 잘 안갈 수 있다. 하지만, 실행 결과를 보며 읽으면 더 쉽게 이해가 될 것같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
     <span class="c1"># 가능한 우선순위 6가지를 딕셔너리 배열 형태로 선언
</span>    <span class="n">priorites</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span><span class="s">'+'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'*'</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="s">'+'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'*'</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="p">{</span><span class="s">'+'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'*'</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="s">'+'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'*'</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
        <span class="p">{</span><span class="s">'+'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'*'</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="p">{</span><span class="s">'+'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'*'</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">]</span>
    
    <span class="c1"># 연산자인지 판별하기 위하 배열 선언
</span>    <span class="n">kind_of_operators</span> <span class="o">=</span> <span class="p">[</span><span class="s">'+'</span><span class="p">,</span> <span class="s">'-'</span><span class="p">,</span> <span class="s">'*'</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'priority: </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
         <span class="c1"># 스택으로 쓸 배열 operators, operands 선언
</span>        <span class="n">operators</span><span class="p">,</span> <span class="n">operands</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="s">''</span>

         <span class="c1"># 입력으로 주어진 문자열을 차례대로 스캔
</span>        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expression</span><span class="p">:</span>

             <span class="c1"># 문자열 e 가 문자열일 경우 
</span>            <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">kind_of_operators</span><span class="p">:</span>

                 <span class="c1"># 연산자를 기준으로 왼쪽에 있던 숫자 tmp를 operands에 저장
</span>                <span class="n">operands</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="s">''</span>
                
                 <span class="c1"># 스택 operators 가 비었다면 바로 e를 추가
</span>                <span class="k">if</span> <span class="ow">not</span> <span class="n">operators</span><span class="p">:</span>
                    <span class="n">operators</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

                 <span class="c1"># operators의 맨끝원소의 연산 우선순위가 스캔중인 
</span>                 <span class="c1"># e 보다 높다면 스택안의 숫자들의 연산을 진행해야한다.
</span>                <span class="k">elif</span> <span class="n">p</span><span class="p">[</span><span class="n">operators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>

                     <span class="c1"># 우선순위가 더 높을 동안 연산을 진행
</span>                    <span class="k">while</span> <span class="n">operators</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="n">operators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
                        <span class="k">print</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span>
                        <span class="k">print</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="n">operands</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="n">operands</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

                         <span class="c1"># eval 연산으로 연산을 하고, str으로 변환한뒤 다시 operands에 추가
</span>                        <span class="n">operands</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">operators</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="p">)))</span>

                     <span class="c1"># 연산 우선순위게 맞게 연산을 진행 한뒤 e를 operators에 추가
</span>                    <span class="n">operators</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

                 <span class="c1"># 연산 우선순위가 더 낮으므로 상관없이 바로 e를 operators에 추가
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="n">operators</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

             <span class="c1"># 문자열 e가 숫자일 경우
</span>            <span class="k">else</span><span class="p">:</span>
                 <span class="c1"># 차례로 e를 tmp에 저장
</span>                <span class="n">tmp</span> <span class="o">+=</span> <span class="n">e</span>

         <span class="c1"># 연산자를 만나지 못했으므로 tmp에 저장된 숫자를 바로 operands에 저장
</span>        <span class="n">operands</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

         <span class="c1"># operators가 빌때까지 모든 연산을 차례로 진행해줌.
</span>        <span class="k">while</span> <span class="n">operators</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">operands</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">operands</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">operands</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">operators</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="p">)))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">print</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>
        
    <span class="n">max_value</span> <span class="o">=</span> <span class="mi">0</span>

     <span class="c1"># 가능한 모든 우선순위에 대해 조사
</span>    <span class="k">for</span> <span class="n">priority</span> <span class="ow">in</span> <span class="n">priorites</span><span class="p">:</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">compute</span><span class="p">(</span><span class="n">priority</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">max_value</span>

<span class="k">print</span><span class="p">(</span><span class="s">'case1'</span><span class="p">)</span>
<span class="k">print</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'max_vlaue: </span><span class="si">{</span><span class="n">solution</span><span class="p">(</span><span class="s">"100-200*300-500+20"</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="k">print</span><span class="p">()</span>
<span class="k">print</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'case2'</span><span class="p">)</span>
<span class="k">print</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'max_vlaue: </span><span class="si">{</span><span class="n">solution</span><span class="p">(</span><span class="s">"2*2*2*2*2-2*2*2"</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case1

priority: {'+': 1, '-': 2, '*': 3}
['100', '200', '300']
['-', '*']
['100', '60000']
['-']
['-59900', '500']
['-']
['-60400', '20']
['+']
-60380

priority: {'+': 1, '-': 3, '*': 2}
['100', '200']
['-']
['-100', '300', '500']
['*', '-']
['-100', '-200']
['*']
['20000', '20']
['+']
20020

priority: {'+': 2, '-': 1, '*': 3}
['100', '200', '300']
['-', '*']
['100', '60000']
['-']
['-59900', '500', '20']
['-', '+']
['-59900', '520']
['-']
-60420

priority: {'+': 2, '-': 3, '*': 1}
['100', '200']
['-']
['-100', '300', '500']
['*', '-']
['-100', '-200', '20']
['*', '+']
['-100', '-180']
['*']
18000

priority: {'+': 3, '-': 1, '*': 2}
['100', '200', '300']
['-', '*']
['100', '60000']
['-']
['-59900', '500', '20']
['-', '+']
['-59900', '520']
['-']
-60420

priority: {'+': 3, '-': 2, '*': 1}
['100', '200']
['-']
['-100', '300', '500', '20']
['*', '-', '+']
['-100', '300', '520']
['*', '-']
['-100', '-220']
['*']
22000

max_vlaue: 60420


case2

priority: {'+': 1, '-': 2, '*': 3}
['2', '2']
['*']
['4', '2']
['*']
['8', '2']
['*']
['16', '2']
['*']
['32', '2', '2']
['-', '*']
['32', '4', '2']
['-', '*']
['32', '8']
['-']
24

priority: {'+': 1, '-': 3, '*': 2}
['2', '2']
['*']
['4', '2']
['*']
['8', '2']
['*']
['16', '2', '2']
['*', '-']
['16', '0']
['*']
['0', '2']
['*']
['0', '2']
['*']
0

priority: {'+': 2, '-': 1, '*': 3}
['2', '2']
['*']
['4', '2']
['*']
['8', '2']
['*']
['16', '2']
['*']
['32', '2', '2']
['-', '*']
['32', '4', '2']
['-', '*']
['32', '8']
['-']
24

priority: {'+': 2, '-': 3, '*': 1}
['2', '2']
['*']
['4', '2']
['*']
['8', '2']
['*']
['16', '2', '2']
['*', '-']
['16', '0']
['*']
['0', '2']
['*']
['0', '2']
['*']
0

priority: {'+': 3, '-': 1, '*': 2}
['2', '2']
['*']
['4', '2']
['*']
['8', '2']
['*']
['16', '2']
['*']
['32', '2', '2']
['-', '*']
['32', '4', '2']
['-', '*']
['32', '8']
['-']
24

priority: {'+': 3, '-': 2, '*': 1}
['2', '2']
['*']
['4', '2']
['*']
['8', '2']
['*']
['16', '2', '2']
['*', '-']
['16', '0']
['*']
['0', '2']
['*']
['0', '2']
['*']
0

max_vlaue: 24
</code></pre></div></div>]]></content><author><name>Kim Boseong</name></author><category term="Programmers" /><category term="python" /><category term="프로그래머스" /><category term="코딩테스트" /><category term="스택" /><summary type="html"><![CDATA[프로그래머스 문제 중 67257번 ‘수식 최대화’ https://programmers.co.kr/learn/courses/30/lessons/67257]]></summary></entry></feed>