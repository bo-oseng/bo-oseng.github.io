I"U <p>백트래킹에 있는 N과 M 시리즈 몇개를 한번에 다루려고 한다.</p>

<h2 id="n-과-m-2-풀이">N 과 M (2) 풀이</h2>

<p>자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.</p>

<ul>
  <li>1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열</li>
  <li>고른 수열은 오름차순이어야 한다.</li>
</ul>

<p>1~n까지 수를 각각 노드로 dfs하되 discovered 배열을 두어 이미 방문했다면 생략하고, discovered의 길이가 m이되면 종료 하게끔 설정을 했다.</p>

<p>주의 할 점은 두가지 정도가 있다.</p>
<ol>
  <li>
    <p>자식 노드들 사이의 탐색을 모두 하기 위해 discoverd 에 1번 자식 노드를 추가하고 dfs를 한뒤 dfs 가 종료된다면 1번 자식 노드를 삭제하고 그 다음 2번자식이 시작 되게끔 해야한다.</p>
  </li>
  <li>
    <p>중복을 제거하기 위해서 dfs를 실시 하는 범위를 중복이 안생기게끔 적절하게 줄여 나가야한다.</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>

 <span class="c1"># 방문한 노드를 표시할 배열 선언
</span><span class="n">discovered</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>

     <span class="c1"># 방문 배열의 크기가 m이 된다면 출력 하고 return으로 재귀 종료
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">discovered</span><span class="p">)</span><span class="o">==</span><span class="n">m</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">discovered</span><span class="p">)</span>
        <span class="k">return</span>

     <span class="c1"># idx를 스캔의 시작점 설정하여 이전 depth에서 추가된 원소의 다음의 원소부터 스캔을 시작한다.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">discovered</span><span class="p">:</span>
            <span class="n">discovered</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">discovered</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

<span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 4
1 2 3 4
</code></pre></div></div>

<h2 id="n-과-m-3-풀이">N 과 M (3) 풀이</h2>

<p>자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.</p>

<ul>
  <li>1부터 N까지 자연수 중에서 M개를 고른 수열</li>
  <li>같은 수를 여러 번 골라도 된다</li>
</ul>

<p><a href="https://bo-oseng.github.io/boj/boj-15649">N 과 M (1)</a>와 다르게 중복이 가능함으로 discovered 에 해당 노드가 있는지 판단하는 조건을 없애면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>

<span class="n">discovered</span><span class="o">=</span><span class="p">[]</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">():</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">discovered</span><span class="p">)</span><span class="o">==</span><span class="n">m</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">discovered</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">discovered</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">dfs</span><span class="p">()</span>
        <span class="n">discovered</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

<span class="n">dfs</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 2
1 1
1 2
1 3
1 4
2 1
2 2
2 3
2 4
3 1
3 2
3 3
3 4
4 1
4 2
4 3
4 4
</code></pre></div></div>

<h2 id="n-과-m-4">N 과 M (4)</h2>

<p>위에 있는 N 과 M (2)와 다르게 중복이 가능함으로 discovered 에 해당 노드가 있는지 판단하는 조건을 없애면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>

<span class="n">discovered</span><span class="o">=</span><span class="p">[]</span>
<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">discovered</span><span class="p">)</span><span class="o">==</span><span class="n">m</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">discovered</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">discovered</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">discovered</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

<span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 3
1 1 1
1 1 2
1 1 3
1 2 2
1 2 3
1 3 3
2 2 2
2 2 3
2 3 3
3 3 3
</code></pre></div></div>

:ET