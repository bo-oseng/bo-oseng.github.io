I"D7<h3 id="문제">문제</h3>

<p>로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.</p>

<p>로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.</p>

<p>로봇 청소기는 다음과 같이 작동한다</p>

<p>1.현재 위치를 청소한다.</p>
<ol>
  <li>현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 인접한 칸을 탐색한다.
    <ul>
      <li>왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.</li>
      <li>왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.</li>
      <li>네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.</li>
      <li>네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.</li>
    </ul>
  </li>
</ol>

<p>로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.</p>

<h3 id="입력">입력</h3>

<p>로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.</p>

<h3 id="출력">출력</h3>

<p>로봇 청소기가 청소하는 칸의 개수를 출력한다.</p>

<hr />

<h2 id="풀이">풀이</h2>

<p>방향이 바뀌는 조건이 조금 까다로웠지만 다음 방향만 잘 조작해준다면 꽤나 쉬운 문제였던것같다.</p>

<p>문제에서 주어진 조건에따라 이동하는 방향과 회전하는 방향을 생각해보자. a조건은 왼쪽에 청소할 수 있는 영역이 있으면 왼쪽으로 회전과 이동을 동시에 수행하고, b 조건은 왼쪽으로 회전만을 , c 조건은 후진으로 이동만을, 그리고 d 조건이라면 종료를한다.</p>

<p>이동과 회전의 동작을 따로 생각하고 왼쪽으로 이동과 뒤쪽으로의 이동을 분리하여 생각해보자</p>

<ol>
  <li>진행조건
    <ul>
      <li>현재 방향을 기준으로 왼쪽방향을 계산한다. 만약 청소가능 구역이 있다면 왼쪽으로 이동하고 탐색을 진행한다.</li>
      <li>청소가능 구역이 없다면 최신화된 방향을 기준으로  탐색을 진행한다.</li>
      <li>네 방향 모두 청소가 이미 되어 있거나 벽인 경우에는, 한칸 후진하고 탐색을 진행한다.</li>
    </ul>
  </li>
  <li>종료조건
    <ul>
      <li>네 방향 모두 청소가 이미 되어 있거나 벽이면서, 방향 기준 뒤에가 벽이라면 종료한다.</li>
    </ul>
  </li>
</ol>

<p>현재 방향을 기준으로 왼쪽과 뒤쪽 방향을 나타낼 딕셔너리 left, back을 활용했다. 현재방향에 대해 각각 왼쪽과 뒤쪽을 나타낸다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># 입력처리
</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">board</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

 <span class="c1"># 좌표를 조작할 dir 선언
</span><span class="nb">dir</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]}</span>

 <span class="c1"># 현재 방향을 기준으로 왼쪽과 뒤쪽 방향을 저장할 딕셔너리 선언
</span><span class="n">left</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="n">back</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

 <span class="c1"># 네방향이 모두 청소가 이미 되었거나 벽인 경우를 판단할 함수 선언
</span><span class="k">def</span> <span class="nf">is_clear_around</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">col</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

 <span class="c1"># 스택을 활요해 DFS를 실행할 함수 선언
</span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>

    <span class="n">s</span> <span class="o">=</span> <span class="p">[[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]]</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
         <span class="c1"># 스택에서 꺼낸후 board[r][c] 가 2가 아니라면 청소를하고 cnt를 1증가
</span>        <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        
         <span class="c1"># 왼쪽부분을 탐색
</span>        <span class="n">lr</span><span class="p">,</span> <span class="n">lc</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">[</span><span class="n">left</span><span class="p">[</span><span class="n">d</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">[</span><span class="n">left</span><span class="p">[</span><span class="n">d</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>

         <span class="c1"># 왼쪽이 청소가 안되었다면 이동후 새로운 탐색 진행
</span>        <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">lr</span><span class="p">][</span><span class="n">lc</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">lr</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="n">left</span><span class="p">[</span><span class="n">d</span><span class="p">]])</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">br</span><span class="p">,</span> <span class="n">bc</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">[</span><span class="n">back</span><span class="p">[</span><span class="n">d</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">[</span><span class="n">back</span><span class="p">[</span><span class="n">d</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>

             <span class="c1"># 네 방향의 조건을 만족할때
</span>            <span class="k">if</span> <span class="n">is_clear_around</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                 <span class="c1"># 뒤에마저 벽이라면 종료
</span>                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">br</span><span class="p">][</span><span class="n">bc</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">cnt</span>
                 <span class="c1"># 뒤가 벽이 아니라면 후진 후 새로운 탐색 진행
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">br</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
                    <span class="k">continue</span>
             <span class="c1"># 네 방향의 조건은 만족하지 못하고 왼쪽이 청소가 불가능하다면 회전만 하고 진행
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">left</span><span class="p">[</span><span class="n">d</span><span class="p">]])</span>



<span class="k">print</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11 10
7 4 0
1 1 1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 0 0 1
1 0 0 0 1 1 1 1 0 1
1 0 0 1 1 0 0 0 0 1
1 0 1 1 0 0 0 0 0 1
1 0 0 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1 0 1
1 0 0 0 0 0 1 1 0 1
1 0 0 0 0 0 1 1 0 1
1 0 0 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1 1 1
57
</code></pre></div></div>

:ET