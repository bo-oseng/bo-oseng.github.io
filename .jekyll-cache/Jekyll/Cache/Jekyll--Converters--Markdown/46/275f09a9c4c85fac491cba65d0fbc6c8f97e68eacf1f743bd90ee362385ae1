I"]*<h1 id="백준-문제중-2775번">백준 문제중 2775번</h1>
<p>https://www.acmicpc.net/problem/2775</p>

<h3 id="문제">문제</h3>

<p>평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.</p>

<p>이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.</p>

<p>아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.</p>

<h3 id="입력">입력</h3>

<p>첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다</p>

<h3 id="출력">출력</h3>

<p>각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.</p>

<hr />

<h2 id="풀이">풀이</h2>

<p>모두가 계약조건에 따른다면 2차원 배열을 선언한뒤 한 층이 올라 갈때마다 각층의 아래층의 n호까지 사람의 합으로 구할 수  있고 이를 코드로 구현 했다.</p>

<h4 id="issue1">Issue1</h4>

<p>입력으로 받을 k,n 도 2차원 배열을 선언해 데이터를 다루려고 했는데 파이썬으로 2차원 배열 구현이 처음이라 약간의 문제가 생겼다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 테스트 케이스수 입렫
</span><span class="n">case</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 2 by case 배열 선언
</span><span class="n">kn</span><span class="o">=</span><span class="p">[[</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]]</span><span class="o">*</span><span class="n">case</span>

<span class="k">print</span><span class="p">(</span><span class="n">kn</span><span class="p">)</span>

<span class="c1"># kn[0][1] 인덱스로 접근해서 원소값 변경
</span><span class="n">kn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>

<span class="c1"># 의도치 않은 결과 발생
</span><span class="k">print</span><span class="p">(</span><span class="n">kn</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
[[None, None], [None, None]]
[[None, 1], [None, 1]]
</code></pre></div></div>

<p>이 문제는 * 연산자의 특징 때문에 발생했다. *연산자는 배열이 값을 각각 할당하는게 아닌 call by reference 즉 참조값을 할당하는 shallow copy 이기 때문이다. 참조값의 메모리에 있는 정보를 바꾸자 같은 참조값을 갖고 있던 인덱스도 변하게 되었다.</p>

<p>이를 해결 하기 위해서는 배열의 원소에 값을 직접 할당하는 접근이 필요하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">case</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="n">kn</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">case</span><span class="p">)]</span>

<span class="k">print</span><span class="p">(</span><span class="n">kn</span><span class="p">)</span>

<span class="n">kn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">kn</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
[[None, None], [None, None]]
[[None, 1], [None, None]]
</code></pre></div></div>

<p>리스트 컴프리헨션으로 문제를 해결했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 계약조건에 맞는 인원을 구하는 함수 선언
</span><span class="k">def</span> <span class="nf">contract</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># 0~k층 1~n호에 맞기 k+1 by n-1 크기 배열 선언
</span>    <span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>     
    
    <span class="c1"># 0층 인원 할당
</span>    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># k층 n호에는 k-1층 n호까지의 합과 같다
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># 0층에서 k층 순으로 출력
</span>    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="c1"># 케이스 수 입력
</span><span class="n">case</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 입력을 저장할 배열 선언
</span><span class="n">kn</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">case</span><span class="p">)]</span>

<span class="c1"># kn 입력
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">case</span><span class="p">):</span>

    <span class="n">kn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

    <span class="n">kn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 각각 k n으로 분리
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">case</span><span class="p">):</span>

    <span class="n">k</span><span class="o">=</span><span class="n">kn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">n</span><span class="o">=</span><span class="n">kn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">contract</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
5
6
[1, 7, 28, 84, 210, 462]
[1, 6, 21, 56, 126, 252]
[1, 5, 15, 35, 70, 126]
[1, 4, 10, 20, 35, 56]
[1, 3, 6, 10, 15, 21]
[1, 2, 3, 4, 5, 6]
462
</code></pre></div></div>

<h3 id="배운점">배운점</h3>
<ol>
  <li>파이썬에서 2차원 배열을 선언하고 다루는 법을 알게되었다.</li>
  <li>*연산자가 shallow copy 라는걸 알게됐다.</li>
</ol>
:ET