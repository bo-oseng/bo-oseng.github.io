I"_?<h1 id="백준-문제-중-2178번">백준 문제 중 2178번</h1>
<p>https://www.acmicpc.net/problem/2178</p>

<h3 id="문제">문제</h3>

<p>N×M크기의 배열로 표현되는 미로가 있다.</p>

<table>
  <thead>
    <tr>
      <th>1</th>
      <th>0</th>
      <th>1</th>
      <th>1</th>
      <th>1</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.</p>

<p>위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.</p>

<h3 id="입력">입력</h3>

<p>첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.</p>

<h3 id="출력">출력</h3>

<p>첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.</p>

<hr />

<h2 id="풀이">풀이</h2>

<h3 id="try1">Try1</h3>
<p>DFS 로 접근.</p>

<p>이 문제의 핵심은 시간제한내에 문제를 풀이하는 것이다.</p>

<p>DFS로 처음부터 끝까지 도달하는 모든경우를 구해 results에 저장하는 식으로 코드를 짰다.</p>

<p>코드의 흐름은 이렇다.</p>
<ul>
  <li>
    <p>dfs(i,j) 함수 내부에서 dfs(i+1,j), dfs(i,j+1), dfs(i-1,j), dfs(i,j-1) 를 재귀적으로 호출한다.</p>
  </li>
  <li>
    <p>재귀를 시작하기전 현재 인덱스는 탐색이 되었으므로 현재 인덱스로 돌아오는걸 방지하기 위해서 maze[i][j] = ‘0’ 으로 설정한뒤 DFS를 시작하고 모든 재귀가 종료되면 다시 원래대로 maze[i][j] =’1’ 으로 바꾸어 준다.</p>
  </li>
  <li>
    <p>위와 마찬가지로 cnt도 재귀를 호출하기전 +1을 해주고 재귀가 끝나면 -1을 해준다.</p>
  </li>
  <li>
    <p>만약 인덱스가 범위를 벗어나거나 미로에서 ‘1’이 아닌 경우에 return하여 재귀를 종료한다.</p>
  </li>
</ul>

<p>이를 코드롤 구현하면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>

<span class="n">maze</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>


<span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">results</span><span class="o">=</span><span class="p">[]</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>

    <span class="k">global</span> <span class="n">cnt</span>

     <span class="c1"># 인덱스가 끝에 도달했다면 cnt 를 results에 추가하고 종료
</span>    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">results</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
        <span class="k">return</span>
    
     <span class="c1"># 인덱스가 범위를 벗어나거나 미로가 '1'이 아닌경우 return
</span>    <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'1'</span><span class="p">:</span>
        <span class="k">return</span>

     <span class="c1"># 재귀를 시작할때와 종료할때 처리
</span>    <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">'0'</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">'1'</span>
    <span class="n">cnt</span><span class="o">-=</span><span class="mi">1</span>


<span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">results</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 6
110110
110110
111111
111101
9
</code></pre></div></div>

<p>그러나 DFS로 한 풀이는 시간초과가 떴다.</p>

<p>DFS 는 경우에 따라서 최단거리를 구하는 알고리즘에 적합하지 않았다.</p>

<h3 id="try-2">Try 2</h3>
<p>BFS 로 접근</p>

<p>위에 코드의 방식 그대로 따라가며 DFS를 BFS로 바꾸려고 했는데 DFS 와 BFS의 차이 때문에 cnt에 문제가 생겼다.</p>

<p>DFS에서는 cnt가 처음부터 끝을 도달할때까지 멈추지 않기 때문에 단순하게 cnt를 1씩 증가시켜주면 구할 수 있었는데 BFS 는 탐색중에 되돌아오는 과정이 있어서 조금 다른 방법으로 cnt를 세야 했다.</p>

<p>이 과정이 조금 어려웠는데 약간은 DP의 응용으로 maze 배열의 각 원소에 그 인덱스까지 도달하는데 걸린 최소 칸을 저장하고 다음 인덱스를 계산할때 이전 인덱스들에 1을 더해주는 식으로 해결했다.</p>

<ul>
  <li>
    <p>큐를 선언하고 시작점은 0,0 이므로 (0,0)을 큐에 넣어준다.</p>
  </li>
  <li>
    <p>이미 탐색을 완료한 maze[0][0]에 1을 대입해 DP를 위한 배열로 활용한다.</p>
  </li>
  <li>
    <p>이미 방문한 노드를 표시할 discovered 리스트를 선언한다.</p>
  </li>
  <li>
    <p>큐가 차있는동안 반복을 시작한다.</p>
  </li>
  <li>
    <p>만약 v,w 이 최종 목적지인 n-1,m-1에 도달한다면 바로 break로 종료한다.</p>
  </li>
  <li>
    <p>v,w 의 상하좌우 인덱스가 범위를 벗어나지않고, maze가 1이 고,  discovered에 존재하지 않을때 q에 [nx,ny]를 추가한다.</p>
  </li>
  <li>
    <p>그리고 현재 경로까지의 칸을 세기위해 maze[nx][ny] 는 이전 인덱스 v,w의 maze 값 즉 maze[v][w]에 +1을 해준다.</p>
  </li>
</ul>

<p>이를 코드로 나타내면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>

<span class="n">maze</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>


<span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">():</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">discovered</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

         <span class="c1"># 방문한 노드 표시를 위해 dicoverd에 추가
</span>        

         <span class="c1"># 최종 인덱스 도달시 최소 칸수 출력후 종료
</span>        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">w</span> <span class="o">==</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">maze</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">break</span>

         <span class="c1"># 상하좌우 인덱스가 범위를 벗어나지 않고,
</span>         <span class="c1"># 아직 방문하지 않았고,
</span>         <span class="c1"># 값이 1일 경우에만 실행
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">v</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">nx</span><span class="o">&lt;</span><span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">ny</span><span class="o">&lt;</span><span class="n">m</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">discovered</span><span class="p">)</span> <span class="ow">and</span> <span class="n">maze</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="s">'1'</span><span class="p">:</span>
                    <span class="n">discovered</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">))</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">))</span>
                    <span class="n">maze</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span><span class="o">=</span><span class="n">maze</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> 

        

<span class="n">bfs</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 6
101111
101010
101011
111011
15
</code></pre></div></div>

<h3 id="배운점">배운점</h3>
<p>최단경로 문제는 DFS보다는 BFS를 먼저 떠올리자.</p>
:ET