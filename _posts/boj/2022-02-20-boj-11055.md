---
layout: single

title: 백준 문제 중 11055번, DP, '가장 큰 부분 증가 수열'

categories:
  - BOJ

tag: [python, 백준온라인저지, 코딩테스트, DP, 다이나믹프로그래밍]

toc: true
---


# 백준 문제 중 11055번
https://www.acmicpc.net/problem/11055

### 문제

수열 A가 주어졌을 때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가 부분 수열은 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 이고, 합은 113이다.

### 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

### 출력

첫째 줄에 수열 A의 합이 가장 큰 증가 부분 수열의 합을 출력한다.

---

## 풀이

입력받을 수열을 nums, nums의 각 인덱스마다 가장 큰 부분수열의 합을 저장하는 배열을 dp라 하자.

0번째 인덱스에서 만들 수 있는 부분수열은 nums[0] 하나이므로 dp[0]=nums[0]을 저장한다.  
  
dp의 i번째 인덱스 즉 dp[i]를 구하는 법을 살펴보자.

우선 nums의 0~i까지 배열 중 0 ~ i-1번째 까지 스캔하며 nums[i]와 값을 비교한다. 스캔하고 있는 인덱스를 j라 하자, nums[j]<nums[i]를 만족할때 nums[j]이후에 nums[i]가 오는 부분수열을 만들 수 있음을 알 수 있다.

  
이는 즉 dp[j]에 해당하는 값의 부분수열 뒤에 nums[i]가 와도 부분수열을 만족한다는 것이고, 이 조건을 만족하는 모든 i이하의 j에대해서 dp[j]+nums[i]중 최댓값을 찾으면 i번째에서의 최대값을 갖는 부분수열의 합 즉 dp[i]를 구할 수 있다.

이를 수도코드로 쓰면 다음과 같다.  
  
dp[i] = max(dp[i],dp[0~i-1 모든 경우]+nums[i])

이를 코드로 구현하면 다음과 같다.


```python
n = int(input())

nums = list(map(int,input().split()))

dp = [0 for _ in range(n)]
 
 # dp 초기값
dp[0] = nums[0]
 
 # 1~n-1까지 진행
for i in range(1,n):

     # i이하의 정수에 대해 스캔
    for j in range(i):

         # 부분 수열을 만들 수 있는 경우
        if nums[j]<nums[i]:

             # 가능한 모든 부분수열 중 최대값
            dp[i] = max(dp[i],dp[j]+nums[i])

print(dp)
print(max(dp))
```

    10
    1 100 2 50 60 3 5 6 7 8
    [1, 101, 3, 53, 113, 6, 11, 17, 24, 32]
    113

