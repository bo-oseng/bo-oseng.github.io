---
layout: single

title: 백준 문제 중 1107번, 브루트포스, '리모컨'

categories:
  - BOJ

tag: [python, 백준온라인저지, 코딩테스트, 브루트포스]

toc: true
---

# 백준 문제 중 1107번
https://www.acmicpc.net/problem/1107

### 문제

수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.

리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다. +를 누르면 현재 보고있는 채널에서 +1된 채널로 이동하고, -를 누르면 -1된 채널로 이동한다. 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.

수빈이가 지금 이동하려고 하는 채널은 N이다. 어떤 버튼이 고장났는지 주어졌을 때, 채널 N으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오. 

수빈이가 지금 보고 있는 채널은 100번이다.

### 입력

첫째 줄에 수빈이가 이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)이 주어진다.  둘째 줄에는 고장난 버튼의 개수 M (0 ≤ M ≤ 10)이 주어진다. 고장난 버튼이 있는 경우에는 셋째 줄에는 고장난 버튼이 주어지며, 같은 버튼이 여러 번 주어지는 경우는 없다.

### 출력

첫째 줄에 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지를 출력한다.

---

## 풀이

이 문제의 핵심은 입력되는 채널의 수가 500000이하인걸 이용하는 것이다.

먼저 채널에 최대한 접근 하는 방법은 채널보다 작을수에서 +로 접근 하는 경우, 채널보다 큰 수에수 -로 접근하는 경우 두가지 이므로 탐색하는 범위를 0 ~ 1000000로 설정한다.

그 다음 스캔하는 동안 고장난 버튼에 해당 된다면 넘어가고 고장이 안난 버튼으로만 만들 수 있는 채널들을 모두 살펴보고 버튼의 횟수를 최소로 하는 cnt를 구하면 된다.


```python
chanel = int(input())

 # 현재채널인 100에서 + -로 가능 경우를 기본값으로 설정
cnt = abs(100-chanel)

 # 고장난 버튼 수 입력
n = int(input())

 # 고장난 버튼이 없을경우 예외처럼
if n:

     # set으로 중복제거
    brk = set(input().split())

else:

    brk = set()

 # 0 ~ 100000을 모두 스캔
for nums in range(100000+1):

    for num in str(nums):

         # 고장버튼이라면 바로 break    
        if num in brk:
            
            break

     # nums를 기준으로 cnt를 세고 이전 cnt 중 최소를 저장
    else:

        cnt = min(cnt,len(str(nums))+abs(nums-chanel))

print(cnt)
```

    80000
    2
    8 9
    2228

