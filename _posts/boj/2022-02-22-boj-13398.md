---
layout: single

title: 백준 문제 중 13398번, DP, '연속합 2'

categories:
  - BOJ

tag: [python, 백준온라인저지, 코딩테스트, DP]

toc: true
---


# 백준 문제 중 13398번
https://www.acmicpc.net/problem/13398

### 문제

n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다. 또, 수열에서 수를 하나 제거할 수 있다. (제거하지 않아도 된다)

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 수를 제거하지 않았을 때의 정답은 12+21인 33이 정답이 된다.

만약, -35를 제거한다면, 수열은 10, -4, 3, 1, 5, 6, 12, 21, -1이 되고, 여기서 정답은 10-4+3+1+5+6+12+21인 54가 된다.

### 입력

첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

### 출력

첫째 줄에 답을 출력한다.

---

## 풀이

상당히 헤맸던 문제이다.

이 문제의 핵심은 시간복잡도를 O(n^2)이 아니도록 하는 것이다. 그러기 위해서 약간의 요령이 필요했다.

아무것도 제외하지 않고 배열 그대로의 [연속합](https://bo-oseng.github.io/boj/boj-1912)을 구하는 것은 앞서 살펴본적이 있다.  
  
배열 nums를 인덱스 1 ~ n-1까지 스캔하면서 dp[i-1] + nums[i]와 nums[i]중 더 큰값을 dp[i]에 저장하면 최대의 연속합을 구할 수 있다. 대략 수도코드로 표현하면 다음과 같다.  
for i in range(1,n):  
 dp[i] = max(dp[i-1] + nums[i], nums[i])

앞선 문제와 이 문제의 차이점은 배열중 한개의 원소를 제외할 후 있다는 것이다. 여기서 한개의 원소를 재외한 연속합을 구하는 방법을 생각해보자. 먼저 nums의 인덱스 1 ~ n-1을 스캔해가면서 하나도 제외하지 않는 연속합을 dp[0][i]에 저장한다.

그 후 dp[1][i]에 한개의 원소를 제외한 연속합의 최대합을 생각 해볼건데 이때 두가지의 경우가 있을 수 있다.  
  
1. i번째의 원소를 제외할경우  
2. i번째 이전의 원소가 이미 제외된 경우  

우리가 고려야해야 할건 i일때의 최댓값이므로  

+ 1번 i를 제거한 경우 연속합은 dp[0][i-1]와 같으므로 dp[0][i-1]
+ 2번 i번째 이전의 원소가 이미 제외된 경우 dp[1][i-1] + nums[i]
  
중 최댓값만을 취해 dp[1][i]를 계속 채워나가면 된다.

이를 코드로 구현하면 다음과 같다.


```python
n = int(input())

nums = list(map(int,input().split()))

dp = [[i for i in nums] for _ in range(2)]

for i in range(1,n):
 
     # 이전에 풀었던 연속합과 같음
    dp[0][i] = max(dp[0][i-1]+nums[i],nums[i])

     # 위의 조건을 코드로 구현
    dp[1][i] = max(dp[0][i-1],dp[1][i-1]+nums[i])


print(dp[0])
print(dp[1])
print(max(max(dp[0]), max(dp[1])))
```

    10
    10 -4 3 1 5 6 -35 12 21 -1
    [10, 6, 9, 10, 15, 21, -14, 12, 33, 32]
    [10, 10, 13, 14, 19, 25, 21, 33, 54, 53]
    54

