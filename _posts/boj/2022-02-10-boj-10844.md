---
layout: single

title: 백준 문제 중 10844번, DP, '쉬운 계단 수'
categories:
  - BOJ

tag: [python, 백준온라인저지, 코딩테스트, DP, 다이나믹 프로그래밍]

toc: true
---

# 백준 문제 중 10844번
https://www.acmicpc.net/problem/10844

### 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

### 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 풀이

1자리의 계단수를 생각해보면  
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 가 있다.

그 다음 2자리의 계단수를 생각해보면  
[10, 21, 12, 32, 23, 43, 34, 54, 45, 65, 56, 76, 67, 87, 78, 98, 89]
여기서 끝자리 수의 개수만 각각 세면  
[1, 1, 2, 2, 2, 2, 2, 2, 2, 1] 이다.

각각 1자리의 계단수다음 +1 이나 -1을 조합한 형태의 수가 된다. 하지만 이때 0의 -1이나 9의 +1의 계단수는 조합이 불가능함을 알 수잇다.

여기서 계단수의 끝자리가 0과 9일때를 제외하고 n+1자리의 계단수중 k로 끝나는 수의 개수는 n자리 계단수의 각 끝자리가 k-1, k+1로 끝나는 계단수의 개수의 합임을 알 수 있다. 그리고 0과 9는 n자리 계단수 중 각각 1, 8로 끝나는 개수임을 알 수있다.  

이를 코드로 나타내면 아래와 같다.


```python

from pprint import pprint

n = int(input())

 # 10*n개의 행렬 선언
dp = [[0 for _ in range(10)] for _ in range(n)]

 # n = 1일 때 초기값 설정
for i in range(1,10):
    dp[0][i] = 1

 # 앞서 설명한 끝자리수의 규칙을 코드로 표현
for i in range(1,n):
    for j in range(1,9):
        dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]
    dp[i][0] = dp[i-1][1]
    dp[i][9] = dp[i-1][8]

print(sum(dp[n-1])%10**9)
pprint(dp)
```

    5
    116
    [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
     [1, 1, 2, 2, 2, 2, 2, 2, 2, 1],
     [1, 3, 3, 4, 4, 4, 4, 4, 3, 2],
     [3, 4, 7, 7, 8, 8, 8, 7, 6, 3],
     [4, 10, 11, 15, 15, 16, 15, 14, 10, 6]]

