---
layout: single

title: Programmers, 2020 카카오 인턴쉽, 스택, '수식 최대화'


categories:
  - Programmers

tag: [python, 프로그래머스, 코딩테스트, 스택]

toc: true

---

# 프로그래머스 2020 카카오 인턴쉽 문제 중 67257번 '수식 최대화'
<a href = 'https://programmers.co.kr/learn/courses/30/lessons/67257'>https://programmers.co.kr/learn/courses/30/lessons/67257</a>

### 문제설명

IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.
이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.
해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.
단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.
만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.

예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.

    "100-200*300-500+20"

일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * > +,- 로 우선순위가 정의되어 있습니다.
대회 규칙에 따라 + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.
수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + > - > * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.
반면에 * > + > - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.

참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.

### 제한사항

+ expression은 길이가 3 이상 100 이하인 문자열입니다.
+ expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.
  + 즉, "402+-561*"처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.
+ expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.
즉, "100-2145*458+12"처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.
"-56+100"처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.
+ expression은 적어도 1개 이상의 연산자를 포함하고 있습니다.
+ 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다.
+ 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.

### 입출력 예

|expression |	result |
|-|-|
|"100-200*300-500+20" |60420 |
|"50*6-3*2" | 	300|


### 입출력 예에 대한 설명

#### 입출력 예 # 1

```* > + > - ```로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.
연산 순서는 아래와 같습니다.
```
100-200*300-500+20
= 100-(200*300)-500+20
= 100-60000-(500+20)
= (100-60000)-520
= (-59900-520)
= -60420
```
따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다.

#### 입출력 예 #2

```- > * ```로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.
연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)
```
50*6-3*2
= 50*(6-3)*2
= (50*3)*2
= 150*2
= 300
```
따라서, 우승 시 받을 수 있는 상금은 300 입니다.

---

## 풀이

연산에 우선순위가 있는 스택 문제로 비슷한 접근법인 [후위 표기식](https://bo-oseng.github.io/boj/boj-1918/)의 Try2 부분을 이전에 다뤄 본적이 있어서 비슷한 방법으로 접근 할 수 있었다. 처음 접했다면 매우 어려웠을 것 같은 문제이다.

먼저 쉽게 풀어 쓰자면, 입력으로 주어진 문자열을 앞에서부터 차례로 스캔하며 연산자들의 스택에 집어 넣다가, 연산 우선순위가 낮은 연산은 나중에 해도 되므로 스택에 남겨 두고, 우선순위가 더 높은 연산자는 다음으로 올 연산자 보다 먼저 계산 해야 하므로 ```( )```을 쳐서 연산을 먼저 하는 것처럼 미리 처리를 해준다고 생각하면 된다.    
  

접근법 중 우선순위에 맞게 계산하는 방법을 요약 하자면 다음과 같다.
1. 연산의 우선순위를 정한다. ( ex) ```p = {'+': 1, '-': 2, '*': 3} ```)
2. 입력으로 주어진 문자열을 처음부터 차레로 스캔하는데 연산자가 아닌 숫자 문자열 이라면 tmp에 저장한다.
3. 입력으로 주어진 문자열을 처음부터 차례로 스캔하며 연산자를 만났을때를 분기로 동작한다. (이때 현재 스캔중인 문자를 e라고 하자)
  1. tmp에 저장된 숫자 문자열을 스택 operands에 저장하고, tmp를 ''로 초기화 한다.
  2. 스택 operators가 비었다면 연산자 e를 스택에 넣는다.
  3. operators의 가장 마지막 원소의 우선순위보다 e의 우선순위가 높다면 (```p[operators[-1]] >= p[e]```) operators가 존재하며, ```p[operators[-1]] >= p[e]``` 동안 스택을 비우며 연산을 진행한다.
  4. 연산이 끝나면 operators에 e를 추가한다.
4. 스캔이 모두 종료되고 나면 연산자를 만나기 전의 tmp가 남아있으므로 tmp를 operands에 저장하고, operators 스택이 빌때까지 모든 연산을 진행한다.  
  
    


글로 쓰여 있는것만 봐서는 이해가 잘 안갈 수 있다. 하지만, 실행 결과를 보며 읽으면 더 쉽게 이해가 될 것같다.


```python
def solution(expression):
     # 가능한 우선순위 6가지를 딕셔너리 배열 형태로 선언
    priorites = [
        {'+': 1, '-': 2, '*': 3},
        {'+': 1, '-': 3, '*': 2},
        {'+': 2, '-': 1, '*': 3},
        {'+': 2, '-': 3, '*': 1},
        {'+': 3, '-': 1, '*': 2},
        {'+': 3, '-': 2, '*': 1},
    ]
    
    # 연산자인지 판별하기 위하 배열 선언
    kind_of_operators = ['+', '-', '*']

    def compute(p):
        print(f'priority: {p}')
         # 스택으로 쓸 배열 operators, operands 선언
        operators, operands = [], []
        tmp = ''

         # 입력으로 주어진 문자열을 차례대로 스캔
        for e in expression:

             # 문자열 e 가 문자열일 경우 
            if e in kind_of_operators:

                 # 연산자를 기준으로 왼쪽에 있던 숫자 tmp를 operands에 저장
                operands.append(tmp)
                tmp = ''
                
                 # 스택 operators 가 비었다면 바로 e를 추가
                if not operators:
                    operators.append(e)

                 # operators의 맨끝원소의 연산 우선순위가 스캔중인 
                 # e 보다 높다면 스택안의 숫자들의 연산을 진행해야한다.
                elif p[operators[-1]] >= p[e]:

                     # 우선순위가 더 높을 동안 연산을 진행
                    while operators and p[operators[-1]] >= p[e]:
                        print(operands)
                        print(operators)
                        b = operands.pop()
                        a = operands.pop()

                         # eval 연산으로 연산을 하고, str으로 변환한뒤 다시 operands에 추가
                        operands.append(str(eval(a + operators.pop() + b)))

                     # 연산 우선순위게 맞게 연산을 진행 한뒤 e를 operators에 추가
                    operators.append(e)

                 # 연산 우선순위가 더 낮으므로 상관없이 바로 e를 operators에 추가
                else:
                    operators.append(e)

             # 문자열 e가 숫자일 경우
            else:
                 # 차례로 e를 tmp에 저장
                tmp += e

         # 연산자를 만나지 못했으므로 tmp에 저장된 숫자를 바로 operands에 저장
        operands.append(tmp)

         # operators가 빌때까지 모든 연산을 차례로 진행해줌.
        while operators:
            print(operands)
            print(operators)
            b = operands.pop()
            a = operands.pop()
            operands.append(str(eval(a + operators.pop() + b)))
        result = int(operands[-1])
        print(result)
        print()
        return result
        
    max_value = 0

     # 가능한 모든 우선순위에 대해 조사
    for priority in priorites:
        max_value = max(max_value, abs(compute(priority)))
    return max_value

print('case1')
print()
print(f'max_vlaue: {solution("100-200*300-500+20")}')
print()
print()
print('case2')
print()
print(f'max_vlaue: {solution("2*2*2*2*2-2*2*2")}')
```

    case1
    
    priority: {'+': 1, '-': 2, '*': 3}
    ['100', '200', '300']
    ['-', '*']
    ['100', '60000']
    ['-']
    ['-59900', '500']
    ['-']
    ['-60400', '20']
    ['+']
    -60380
    
    priority: {'+': 1, '-': 3, '*': 2}
    ['100', '200']
    ['-']
    ['-100', '300', '500']
    ['*', '-']
    ['-100', '-200']
    ['*']
    ['20000', '20']
    ['+']
    20020
    
    priority: {'+': 2, '-': 1, '*': 3}
    ['100', '200', '300']
    ['-', '*']
    ['100', '60000']
    ['-']
    ['-59900', '500', '20']
    ['-', '+']
    ['-59900', '520']
    ['-']
    -60420
    
    priority: {'+': 2, '-': 3, '*': 1}
    ['100', '200']
    ['-']
    ['-100', '300', '500']
    ['*', '-']
    ['-100', '-200', '20']
    ['*', '+']
    ['-100', '-180']
    ['*']
    18000
    
    priority: {'+': 3, '-': 1, '*': 2}
    ['100', '200', '300']
    ['-', '*']
    ['100', '60000']
    ['-']
    ['-59900', '500', '20']
    ['-', '+']
    ['-59900', '520']
    ['-']
    -60420
    
    priority: {'+': 3, '-': 2, '*': 1}
    ['100', '200']
    ['-']
    ['-100', '300', '500', '20']
    ['*', '-', '+']
    ['-100', '300', '520']
    ['*', '-']
    ['-100', '-220']
    ['*']
    22000
    
    max_vlaue: 60420
    
    
    case2
    
    priority: {'+': 1, '-': 2, '*': 3}
    ['2', '2']
    ['*']
    ['4', '2']
    ['*']
    ['8', '2']
    ['*']
    ['16', '2']
    ['*']
    ['32', '2', '2']
    ['-', '*']
    ['32', '4', '2']
    ['-', '*']
    ['32', '8']
    ['-']
    24
    
    priority: {'+': 1, '-': 3, '*': 2}
    ['2', '2']
    ['*']
    ['4', '2']
    ['*']
    ['8', '2']
    ['*']
    ['16', '2', '2']
    ['*', '-']
    ['16', '0']
    ['*']
    ['0', '2']
    ['*']
    ['0', '2']
    ['*']
    0
    
    priority: {'+': 2, '-': 1, '*': 3}
    ['2', '2']
    ['*']
    ['4', '2']
    ['*']
    ['8', '2']
    ['*']
    ['16', '2']
    ['*']
    ['32', '2', '2']
    ['-', '*']
    ['32', '4', '2']
    ['-', '*']
    ['32', '8']
    ['-']
    24
    
    priority: {'+': 2, '-': 3, '*': 1}
    ['2', '2']
    ['*']
    ['4', '2']
    ['*']
    ['8', '2']
    ['*']
    ['16', '2', '2']
    ['*', '-']
    ['16', '0']
    ['*']
    ['0', '2']
    ['*']
    ['0', '2']
    ['*']
    0
    
    priority: {'+': 3, '-': 1, '*': 2}
    ['2', '2']
    ['*']
    ['4', '2']
    ['*']
    ['8', '2']
    ['*']
    ['16', '2']
    ['*']
    ['32', '2', '2']
    ['-', '*']
    ['32', '4', '2']
    ['-', '*']
    ['32', '8']
    ['-']
    24
    
    priority: {'+': 3, '-': 2, '*': 1}
    ['2', '2']
    ['*']
    ['4', '2']
    ['*']
    ['8', '2']
    ['*']
    ['16', '2', '2']
    ['*', '-']
    ['16', '0']
    ['*']
    ['0', '2']
    ['*']
    ['0', '2']
    ['*']
    0
    
    max_vlaue: 24
    
